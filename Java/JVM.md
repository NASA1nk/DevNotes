# 字节码

在 Java 中，JVM可以理解的代码就叫做字节码（即扩展名为 `.class` 的文件）

- 它不面向任何特定的处理器，**只面向虚拟机**
- Java 语言通过字节码的方式，在一定程度上**解决了传统解释型语言执行效率低的问题**，同时又保留了解释型语言可移植的特点

**运行过程**

1. `.java`文件通过javac编译成`.class`文件
2. `.class`文件通过解释器和JIT编译成机器码

![编辑字节码文件](JVM.assets/编辑字节码文件.png)

## 编译与解释

高级编程语言按照**程序的执行方式**分为两种

- **编译型语言**
  - 通过编译器将源代码**一次性翻译**成可被该平台执行的机器码
  - 一般情况下，编译语言的执行速度比较快，开发效率比较低
  - 常见的编译性语言有C、C++、Go、Rust等
- **解释型语言** 
  - 通过**解释器一句一句**的将代码解释（interpret）为机器代码后再执行
  - 解释型语言开发效率比较快，执行速度比较慢
  - 常见的解释性语言有Python、JavaScript、PHP等

**编译与解释共存**

- 首先由Java**编译器**将源程序**编译**成`.class`字节码文件
- JVM**类加载器**加载字节码文件，然后通过解释器**逐行解释**执行
- 编译+解释的方式比较慢，考虑到有些方法和代码块是经常需要被调用的（所谓的热点代码），于是引进了 JIT（just-in-time compilation） **编译器优化**
  - JIT属于**运行时编译**

  - 当JIT编译器完成第一次编译后，会**将字节码对应的机器码保存下来，下次可以直接使用**

> HotSpot：采用了惰性评估（Lazy Evaluation）的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码）
>
> 这也就是JIT所需要编译的部分
>
> 由于java对于多种不同的操作系统有不同的JVM，所以 Java实现了真正意义上的跨平台

![JIT即时编译](JVM.assets/JIT即时编译.png)

# 内存区域

运行时数据区

## 程序计数器

Program Counter **Register**

- **线程私有**
- 保证线程切换时能正确恢复

## 虚拟机栈

Java Virtual Machine **Stack**

- **线程私有**
- 每个方法被执行时，JVM都会创建一个栈帧
  - 栈帧用来保存参数，局部变量，中间计算过程和其他数据
- 栈中的**局部变量表**存放编译时可知的**基本数据类型变量和对象的引用变量**
  - 数据类型在表中的存储空间表示为局部变量槽
  - 所需要的内存空间在编译时确定，**方法运行期间不会改变大小**

> 栈中存放对象引用，但是对象不在栈中，而是存放在堆中（new出来的对象）或常量池中（字符串常量）

## 本地方法栈

Native Method **Stack**

- **线程私有**
- 为本地方法服务

## 堆

Java **Heap**

- **被所有线程共享**
- JVM管理的内存区域的最大的一块内存
- 几乎所有**对象实例和数组**都存放在堆中（在堆上为其分配内存）
  - 有的对象在栈上分配
- **垃圾收集器管理的主要内存区域，也称为GC堆**
  - 收集器基本都采用**分代垃圾收集算法**，所以堆还可以细分为新生代和老年代
    - jdk8移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域
    - 进一步划分的目的是更好地回收内存，以及更快地分配内存
- 堆可以划分出多个**线程私有的分配缓冲区**
  - TLAB：**Thread** Local Allocation Buffer
  - 为了更好的回收，以及更快的分配内存
- 堆可以处于物理上不连续的内存空间，**但逻辑上应该被视为连续的**

## 方法区

Method Area

- **被所有线程共享**
- 存储被JVM加载的**类型信息，常量，静态变量**
- 为了让GC可以像管理堆一样管理方法区，HotSpot虚拟机在JDK8之前使用**永久代**来实现方法区

### 运行时常量池

- 是方法区的一部分
- `.class`文件中有一项**常量池表**（Constant Pool Table），存放编译时生成的各种**字面量和符号引用**，在**类加载后**存放在方法区中的运行时常量池中
- 不同于`.class`文件中的常量池表，**运行时常量池具有动态性**
  - 运行期间可以将新的常量放入池中

> JDK7及之后版本的JVM将**运行时常量池**从方法区中移了出来，在Java**堆中**开辟了一块区域存放运行时常量池

### 直接内存

Direct Memory

- 不是JVM中定义的内存区域，也不是JVM运行时数据区的一部分
  - 受本机内存和处理器寻址空间限制
- JDK1.4引入了NIO（`New Input/Ouput`）类，引入了基于**通道**（Channel）和**缓冲区**（Buffer）的I/O方式。使用`Native`函数直接分配**堆外内存**，然后通过存储在堆中的`DirectByteBuffer`对象作为这块**内存的引用**进行操作



## 对象

HotSpot虚拟机在**堆（heap）**中操作对象

### 对象的创建

**`new`+普通Java对象**：只要使用`new`方法，便需要创建新的对象

> 还有复制，反序列化，还有数组和class对象
>

1. JVM检查指令参数能否**在常量池中定位到一个类的符号引用**，并且进行类加载检查

   1. 检查符号引用代表的类是否已经被加载，解析和初始化
   2. 如果没有，则需要先执行相应的类加载过程

2. JVM为对象分配内存，**分配空间大小在类加载完成后就可以确定**。JVM从堆中划分一块区域，划分方法取决于**堆内存的规整性**，堆内存的规整性由使用的**垃圾收集器是否能进行空间压缩整理**所决定的

   1. 堆内存规整：采用**指针碰撞**（Bump The Pointer）的分配方式
      1. 使用过的内存和未使用的内存之间**用一个指针作为分界指示器**
      2. 分配内存只需要将指针向空闲内存方向挪动对象大小的距离
   2. 堆内存不规整：采用**空闲列表**（Free List）的分配方式
      1. 使用过的内存和未使用的内存交织在一起，需要**维护一个列表来记录未使用的内存块**
      2. 从列表上找到一个足够大的空间分配给对象实例，然后更新表

3. 并发场景下的内存分配（线程不安全）

   > 可能在给对象A分配内存的时候，给对象B同时分配内存，并且使用了同一个指针

   1. **本地线程分配缓冲**（TLAB：Thread Local Allocation Buffer）
      1. 将内存分配的动作根据线程划分在不同空间之间进行
      2. 给每个线程预先在堆内存中分配一块区域，即TLAB，线程分配内存时，就在TLAB中分配，TLAB用完后才使用同步锁定在堆中分配

4. JVM**将分配的内存空间初始化为零值**

   1. 如果有TLAB，则可以提前到TLAB分配时初始化
   2. 保证对象实例在代码中不赋初始值也可以直接使用

5. JVM设置对象信息，存放在**对象头**（Object Header）中

   1. 对象是哪个类的实例
   2. 对象的hashcode值
   3. 对象的GC分代年龄

6. 按照代码的意愿初始化对象，构造出一个真正可用的对象实例

   1. 执行`.class`文件的`<init>()`方法

![对象创建过程](JVM.assets/对象创建过程.png)

### 并发场景下的内存分配

在实际开发过程中，创建对象是很频繁的事情，虚拟机必须要保证线程是安全的，通常虚拟机采用两种方式来**保证线程安全**

- **CAS+失败重试**
  
  - CAS是乐观锁的一种实现方式
  - **虚拟机采用CAS配上失败重试的方式保证更新操作的原子性**
  
  > 乐观锁：每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止
  
- **TLAB**
  
  - **为每一个线程预先在Eden区分配一块儿内存**
  - JVM在给线程中的对象分配内存时，首先在TLAB分配
  - 当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配



## 对象的内存布局

对象在堆内存中的存储布局

### **对象头**

Header

- **Mark Word**：存储对象自身的运行时数据
  - hashcode值
  - GC分代年龄
  - 锁状态标志
  - **线程持有的锁**
- **类型指针**：对象指向它的类型元数据的指针
  - JVM通过指针来确定**是哪个类的对象实例**

### 实例数据

Instance Data

- 对象的有效信息，即代码中定义的**字段内容**
- 相同宽度的对象会被放在一起
  - 父类中定义的变量会放在子类之前

### 对齐填充

Padding

- 非必须，HotSpot虚拟机要求对象的起始地址是8字节的整数倍

## 对象的访问定位

Java程序通过**栈中的对象引用来操作堆中的对象**

JVM决定引用来定位访问对象的实现

- **句柄访问**：Java堆中会划分出一块内存作为**句柄池**
  - 引用中存放**对象的句柄地址**
  - 句柄中存放**对象实例数据**和**对象类型数据**的具体地址信息
  - 在对象被移动时只需要修改句柄中的实例地址，引用中的句柄地址不变
- **直接指针访问**：需要考虑如果存放**对象类型数据**信息
  - 引用中存放的直接就是对象在堆中的地址
  - 少一次间接访问的开销



# 垃圾收集器

GC：Garbage Collection

- 哪些内存需要回收
- 什么时候回收
- 如何回收

> GC比Java久

**确定性**

- 程序计数器，虚拟机栈，本地方法栈**随线程创建，消亡**。栈帧**随方法的进入，退出执行出入栈**。所以当方法或线程结束时，这些内存就回收了

**不确定性**

- Java**堆和方法区**，这些内存的回收是动态的

Java自动内存管理最核心的功能是**堆内存中对象的分配与回收**



## 对象死亡

堆内存中几乎存放着所有的对象实例，堆垃圾回收前**要判断哪些对象已经死亡**，即不能再被任何途径使用的对象

### 引用计数算法

给对象添加一个**引用计数器**。每当有一个地方引用它，计数器就加1，当引用失效，计数器就减1

- 任何时候**计数器为0的对象就是不能再被使用的**

引用计数法实现简单，效率高，但是**目前主流的虚拟机中并没有选择这个算法来管理内存**

- 其最主要的原因是它很**难解决对象之间相互循环引用的问题**

- 对象之间的**相互引用会导致它们的引用计数器都不为0**，于是引用计数算法无法通知GC回收器回收它们

### 可达性分析算法

通过一系列的称为**GC Roots**的对象作为起点集，从这些节点开始，根据引用关系向下搜索，**搜索过程所走过的路径称为引用链**（Reference Chain）

- 当一个对象到GC Roots之间没有任何引用链的话（GC Roots到此对象不可达），则此对象就是不能再被使用的

> Java，c#都是用此方法进行GC

**不可达的对象不一定一定死亡**

- **即使在可达性分析法中不可达的对象，也并非是非死不可的**
- 要真正宣告一个对象死亡，**至少要经历两次标记过程**
  - 可达性分析法中**不可达的对象被第一次标记并且进行一次筛选**，筛选的条件是此对象是否有必要执行`finalize()`方法
    - 当对象没有覆盖`finalize()`方法，或`finalize()`方法已经被JVM调用过时，JVM会将这两种情况视为**没有必要执行**
  - **被判定为需要执行的对象将会被放在一个队列中进行第二次标记**，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收（真的死亡）

### 引用

无论是通过引用计数算法判断对象引用数量，还是通过可达性分析算法判断对象的引用链是否可达，**判定对象的存活都与引用有关**

JDK1.2前，引用的定义是**如果reference类型的数据存储的数值代表的是另一块内存的起始地址，就称这个数据是代表某块内存或某个对象的引用**

- 这种定义下只有引用和被引用的概念，不够具体

JDK1.2后扩充了引用的概念，下面4种引用强度逐渐减弱

- **强引用**
- **软引用**
- **弱引用**
- **虚引用**

#### 强引用

- 强引用就是最传统的引用，即程序中普遍存在的引用赋值
- 如果一个对象具有强引用，垃圾回收器就绝不会回收它
- 当内存空间不足时，JVM宁可抛出OutOfMemoryError使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题

#### 软引用

- 如果一个对象只具有软引用，**如果内存空间足够，垃圾回收器就不会回收它**，**如果内存空间不足，就会回收这些对象的内存**
  - 如果回收后内存空间还是不足，JVM才会抛出OutOfMemoryError
- 只要垃圾回收器没有回收具有软引用的对象，它就可以被程序使用
- **软引用可用来实现内存敏感的高速缓存**
- 软引用可以和一个引用队列（ReferenceQueue）联合使用
  - 如果软引用所引用的对象被垃圾回收，JVM就会把这个软引用加入到与之关联的引用队列中

#### 弱引用

- 弱引用与软引用的区别在于：**只具有弱引用的对象拥有更短暂的生命周期**
- 如果一个对象只具有弱引用，它只能生存到下一次垃圾回收为止
  - 不管当前内存空间足够与否，都会回收弱引用对象的内存
  - 不过由于垃圾回收器是一个优先级很低的线程， 因此它不一定会很快发现那些只具有弱引用的对象
- 弱引用可以和一个引用队列（ReferenceQueue）联合使用
  - 如果弱引用所引用的对象被垃圾回收，JVM就会把这个弱引用加入到与之关联的引用队列中

#### 虚引用

- 又叫**幽灵引用**和**幻影引用**，是最弱的一种引用关系
- 虚引用与其他几种引用都不同，虚引用并不会决定对象的生命周期
- 如果一个对象仅持有虚引用，**那么它就和没有任何引用一样**，在任何时候都可能被垃圾回收
- 虚引用的作用只是在垃圾回收时可以收到通知，可以用来跟踪对象被垃圾回收的活动

- 虚引用与软引用和弱引用的一个区别在于： **虚引用必须和引用队列（ReferenceQueue）联合使用**
  - 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收该对象的内存之前把这个虚引用加入到与之关联的引用队列中
  - 程序可以通过判断引用队列中是否已经加入了虚引用来了解被引用的对象是否将要被垃圾回收
  - 程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动 

> 在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多。因为**软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**

### 废弃常量

**运行时常量池**主要回收的是废弃的常量

- 假如在常量池中存在字符串`"abc"`，如果**当前没有任何`String`对象引用该字符串常量的话**，就说明常量"abc"是废弃常量，如果这时发生内存回收的话**而且有必要的话**，`"abc"`就会被系统清理出常量池


> JDK1.7后JVM将运行时常量池从方法区中移了出来，在堆（Heap）中开辟了一块区域存放运行时常量池

### 无用类

**方法区**主要回收的是无用的类

无用的类需要同时满足3个条件 

- **该类所有的实例都已经被回收**，即堆中不存在该类的任何实例
- **加载该类的ClassLoader已经被回收**
- 该类对应的java.lang.Class对象没有在任何地方被引用，**无法在任何地方通过反射访问该类的方法**

> JVM可以对无用类进行回收，但并不会和死亡对象一样必然被回收



## 堆内存

堆内存分为

- **新生代**
- **老年代**
- **永久代**

### 分配策略

目前主流的垃圾收集器都会采用**分代回收算法**，因此需要将堆内存分为新生代和老年代，这样就可以根据各个年代的特点选择合适的垃圾收集算法

- 对象优先在eden区分配
- 大对象直接进入老年代
- 长期存活的对象将进入老年代

> 大对象：需要大量连续内存空间的对象，如字符串和数组

### 元空间

- 在JDK8中移除了整个永久代，取而代之的是一个叫**元空间**（Metaspace）的区域
  - **永久代使用的是JVM的堆内存空间**
  - **元空间使用的是物理内存**，直接受到本机的物理内存限制

### 新生代

新生代分为

- **Eden区**
- **Survior1区**
- **Survior2区**

大多数情况下，**对象在新生代中eden区分配**。当eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC

- 即使程序什么也不做，新生代也会使用2000多k内存
- 执行Minor GC后，后面分配的对象如果能够存放在eden区，还是会在eden区分配内存

**Minor Gc和Full GC**

- **Minor GC（新生代GC）**：指发生新生代的GC，Minor GC非常频繁，回收速度一般也比较快
- **Major GC/Full GC（老年代GC）**：指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上

### 老年代

大对象直接进入老年代

- 避免为大对象分配内存时由于**分配担保机制**带来的复制而降低效率

长期存活的对象将进入老年代

- 为了在GC时能够识别哪些对象应该放在新生代，哪些对象应该放在老年代，JVM给每一个对象设置了一个**对象年龄计数器**（Age）

**对象年龄计数器**

- 如果对象在eden区出生并经过第一次Minor GC后仍然能够存活并且能被Survivor区容纳的话，**将被移动到Survivor区中，并将对象年龄设为1**
- 对象在Survivor区每经历一次MinorGC，年龄就增加1岁
- 当对象的年龄增加到一定程度（**默认为15岁**），就会被晋升到老年代中。
  - 对象晋升到老年代的年龄阈值可以通过参数`-XX:MaxTenuringThreshold`设置

**动态对象年龄判断**

- 为了更好的适应不同程序的内存情况，JVM不是永远要求对象年龄必须达到了某个值才能进入老年代
- 如果**Survivor区中相同年龄所有对象大小的总和大于Survivor区大小的一半**，那么年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到要求的年龄





## 垃圾收集算法

内存回收的方法论

### 标记-清除算法

最基础的收集算法，效率也很高。分为**标记**和**清除**两个阶段

1. 首先标记出所有需要回收的对象
2. 在标记完成后**统一回收所有被标记的对象**

存在问题

1. 效率问题
2. 空间问题：标记清除后会**产生大量不连续的碎片**

### 复制算法

为了**解决效率问题**而设计的复制收集算法

1. 它可以将**内存分为大小相同的两块**，每次使用其中的一块
2. 当这一块的内存使用完后，**就将还存活的对象复制到另一块中**，然后再把使用的空间一次清理掉
3. 这样就使每次的内存回收都是**对内存区间的一半进行回收**

### 标记-整理算法

根据**老年代的特点**设计的一种标记算法

- **标记过程和标记-清除算法一样**
- 但不直接对可回收对象回收，而是**让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存**

### 分代收集算法

当前虚拟机的垃圾收集都采用分代收集算法

- 分代收集算法根据**对象存活周期**的不同将内存分为几块
- 一般**将Java堆分为新生代和老年代**，这样就可以根据各个年代的特点选择合适的垃圾收集算法
  - 比如在新生代中，每次垃圾收集都会有大量对象死去，所以可以选择**复制算法**
    - 只需要付出少量对象的复制成本就可以完成垃圾收集
  - 老年代的对象存活几率比较高，而且没有额外的空间对它进行分配担保，所以必须选择**标记-清楚**或**标记-整理**算法进行垃圾收集

> HotSpot为什么要分为新生代和老年代？
>
> - 划分的目的是更好地回收内存，以及更快地分配内存
> - 可以根据各个年代的特点选择合适的垃圾收集算法

## 垃圾收集器

内存回收的具体实现

现在还没有最好的垃圾收集器出现，更没有万能的垃圾收集器。要根据具体的应用场景选择适合的垃圾收集器

### Serial收集器

串行收集器收集器是最基本、历史最悠久的垃圾收集器，它是一个**单线程收集器**

- **它只会使用一个垃圾收集线程去完成垃圾收集工作**
- 它在进行垃圾收集工作的时候**必须暂停其他所有的工作线程**，直到它收集结束
- **新生代采用复制算法，老年代采用标记-整理算法**
- 用户线程的停顿导致体验很差，但由于没有线程交互的开销，有很高的单线程收集效率

> Stop The World

### Serial Old收集器

**Serial收集器的老年代版本**。同样是一个单线程收集器，主要有两大用途

- 在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用
- 作为CMS收集器的后备方案

### ParNew收集器

ParNew收集器其实就是**Serial收集器的多线程版本**

- 除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样
- **新生代采用复制算法，老年代采用标记-整理算法**

> 除了Serial收集器外，只有ParNew收集器能与CMS收集器配合工作



### Parallel Scavenge收集器

Parallel Scavenge收集器类似于ParNew收集器

- Parallel Scavenge收集器的关注点是吞吐量，如何高效率的利用CPU

  - 吞吐量就是CPU中用于**运行用户代码的时间**与CPU总消耗时间的比值。 

  - 提供了很多参数**供用户找到最合适的停顿时间或最大吞吐量**

-  **新生代采用复制算法，老年代采用标记-整理算法**

> CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）

### Parallel Old收集器

**Parallel Scavenge收集器的老年代版本**

- 使用多线程和**标记-整理算法**
- 在注重吞吐量以及CPU资源的场合，都可以优先考虑Parallel Scavenge收集器和Parallel Old收集器

### CMS收集器

CMS（Concurrent Mark Sweep）：同时标记扫描

- 一种以**获取最短回收停顿时间**为目标的收集器，非常符合在注重用户体验的应用上使用

- 是HotSpot虚拟机第一款**真正意义上的并发收集器**，它第一次实现了**让垃圾收集线程与用户线程（基本上）同时工作**

CMS收集器使用**标记-清除算法**实现，整个回收过程分为四个步骤

- **初始标记**
  - **暂停所有的其他线程**，并记录下直接与GC Roots相连的对象
  - 初始标记阶段速度很快
- **并发标记**
  - **同时开启GC线程和用户线程**，用一个闭包结构去记录可达对象
  - 因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性，即这个闭包结构**并不能保证包含当前所有的可达对象**，所以这个算法里会**跟踪记录这些发生引用更新的地方**
- **重新标记** 
  - 修正并发标记期间因为用户程序运行导致的标记产生变动的那一部分对象的标记记录
  - 重新标记阶段的停顿时间一般会比初始标记阶段的时间稍长，**远远比并发标记阶段时间短**
- **并发清除**
  - 开启用户线程，同时GC线程开始对为标记的区域做清扫

> 只在初始标记阶段暂停其他用户线程

**优点**

- 并发收集，低停顿

**缺点**

- 对CPU资源敏感
- 无法处理浮动垃圾
- 使用标记-清除算法会导致收集结束时会有大量空间碎片产生



### G1收集器

G1（Garbage-First）：**面向服务器的垃圾收集器**，主要针对配备**多颗处理器及大容量内存**的机器。以极高概率满足GC停顿时间要求的同时还具备高吞吐量性能特征

**特点**

- **并行与并发**
  - G1收集器能充分利用CPU、多核环境下的硬件优势，使用多个CPU或者CPU核心来缩短Stop The World停顿时间
  - 部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然**可以通过并发的方式让java程序继续执行**

- **分代收集**
  - 虽然**G1可以不需要其他收集器配合就能独立管理整个GC堆**，但还是保留了分代的概念

- **空间整合**
  - 与CMS的标记-清理算法不同，**G1从整体来看是基于标记-清理算法实现的收集器，从局部上来看是基于复制算法实现的**

- **可预测的停顿**
  - 是G1相对于CMS的另一个大优势，**降低停顿时间**是G1和CMS共同的关注点
  - G1除了追求低停顿外，还能**建立可预测的停顿时间模型**，能让使用者明确指定在一个长度为M毫秒的时间片段内



G1收集器的整个回收过程分为四个步骤

- **初始标记**
- **并发标记**
- **最终标记**
- **筛选回收**

**G1收集器在后台维护了一个优先列表**

- **每次根据允许的收集时间，优先选择回收价值最大的Region**
- 这种使用Region划分内存空间以及**具有优先级的内存区域回收方式**，保证了G1收集器在有限时间内有尽可能高的收集效率

> 这也是它名字Garbage-First的由来
