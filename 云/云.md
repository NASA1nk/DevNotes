# 云

云是网络，互联网的一种比喻说法，**云是互联网连接的另一端**

- 可以从云端访问各种应用程序和服务
- 可以在云端安全存储数据

**优点**

- 不需要对云进行维护或管理
- 云端可以有效扩容至无限大，无需担心云容量不够用
- 可以随时随地访问基于云的各种应用程序和服务，只需要一台可以连接互联网的设备即可

# 云计算

- 云计算是多种传统计算机和网络技术发展融合的产物

  - 分布式计算（Distributed Computing）

  - 并行计算（Parallel Computing）

  - 效用计算（Utility Computing）

  - 网络存储（Network Storage Technologies）

  - 虚拟化（Virtualization）

  - 负载均衡（Load Balance）

  - 热备份冗余（High Available）

- 云计算是一种将可伸缩、弹性、共享的物理和虚拟资源池以按需自服务的方式供应和管理，并提供网络访问的模式
  - 云计算模式由关键特征、云计算角色和活动、云能力类型和云服务分类、云部署模型、云计算共同关注点组成
- 云计算是一种基于互联网的计算方式，通过这种方式，共享的软硬件资源和信息可以按需求提供给计算机各种终端和其它设备

> 提供一种服务，即云服务

# 云服务

经典的云计算架构分为**三大服务层**

- IaaS（Infrastructure as a Service）：**基础设施即服务**
  - 云服务的最底层，IaaS层通过**虚拟化技术**提供计算、存储、网络等基础资源，可以在上面部署各种OS以及应用程序
  - 主要由运维工程师管理负责
  - 应用开发者可以通过云厂商提供的API控制整个基础架构，无须对其进行**物理上的维护和管理**
- PaaS（Platform as a Service）：**平台即服务**
  - PaaS层提供软件部署平台（runtime），**抽象掉了硬件和操作系统**，可以无缝地扩展（scaling）
  - 封装了底层资源（数据库、语言环境等），主要由应用开发者管理负责
  - 应用开发者只需要关注自己的业务逻辑，不需要关注底层
- SaaS（Software as a Service）：**软件即服务**
  - SaaS 层直接为开发者提供软件服务，将软件的开发、管理、部署等全部都交给第三方
  - 用户不需要再关心技术问题，可以拿来即用  

# 云原生

> 2010年，WSO2的创始人Paul Fremantle提出了云原生（Cloud native）一词。经历了10多年的发展和技术变革，云原生的定义和内涵都有了很大的变化
>
> 目前云原生计算基金会（CNCF）对云原生的定义如下
>
> - 云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，**构建和运行可弹性扩展的应用**
> - 云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式API
>
> 强调生而为云，即应用要部署在以云为载体的动态环境中

**云原生是一种构建和运行应用程序的方法，是一套技术体系和方法论**，是建立在一套**开源中间件**基础上的云计算技术，**属于云计算的PaaS层服务**

- 容器技术
- 微服务技术
- DevOps技术
- 持续交付技术（CD）

**云原生（Cloud Native）是一个组合词：云+原生（Cloud+Native）**

- 云（Cloud）：表示应用程序部署在云中，而不是传统的数据中心
- 原生（Native）：表示应用程序从设计之初即考虑到云的环境，**原生为云而设计**
  - 在云上以最佳姿势运行，充分利用和发挥**云平台的弹性+分布式优势**

所以一切开发基于云上，符合云原生架构的应用程序

- 采用开源堆栈（K8S+Docker）进行容器化，是微服务的最佳载体
- 基于微服务架构提高灵活性和可维护性，借助敏捷方法、DevOps支持持续交付，自动化发布和运维自动化
- 利用云平台设施实现独立部署，弹性伸缩、动态调度、优化资源利用率

# 云原生应用

## 动态变化

**云原生应用的外部形态和内部结构是动态变化的**

- 从本质上讲，云平台提供的核心能力是复制（Replication），可以将各种类型的工作负载以手动或自动的方式进行复制和销毁，从而让应用具有弹性伸缩的能力
- 因此，云上应用比传统应用更容易扩展，在规模和外部形态上是基于流量需求动态变化的。这是云原生应用之于传统应用比较大的区别
- 微服务应用架构可以让每个服务独立开发、部署、运行
  - 这种构建方式可以让应用按需迭代，像细胞分裂再生一般不断更新，实现所谓的**演进式设计**
  - 这种特性使得应用在内在的组织结构上也是动态变化的，微服务应用的各个组成部分都可以独立演进，且每一个服务自身也可以基于需要独立扩展

## 核心业务

**云原生应用以业务构建为核心**

- 构建一个**分布式系统**通常要实现3部分内容
  - 业务逻辑
  - 控制逻辑
  - 技术框架
- **业务逻辑**：为客户实现商业价值的核心所在，也是主要的开发活动
- **控制逻辑**：用来辅助业务逻辑完成一些特定的需求，称之为**非功能性需求**
  - 比如把数据切分成多段进行传输、用循环实现一个重试功能等
  - 控制逻辑通常会利用中间件、类库的方式实现复用
- **技术框架**：提供了封装好的模型、流程和工具库，提升了开发效率
  - 框架并不是必须的，完全可以基于语言特性直接开发应用

只有业务逻辑是客户所要求的，但因为应用在性能、可用性、可扩展性等一系列质量属性的需要，**不得不开发一系列的和业务无关的非功能性需求**，这些属于额外的工作，而且这些工作的开发时间占比很可能超过了业务本身

而现在云平台的计算、存储、网络、安全等各种资源和能力面面俱到，大量的非功能性需求都下沉到了基础设施层面

越来越多的资源、特性、能力都可以通过云平台实现，所以**应用开发者只需要管理好自己的数据，即业务本身**，利用云的能力获取、而不是自己开发非功能性需求，从而让开发过程变成纯粹而高效

## 绞杀者模式

Strangler Pattern

**绞杀者模式是一种系统重构技术**，软件开发行业中一种重写系统的方式，即围绕旧系统逐步创建一个新系统，让它慢慢成长，直到旧系统被完全替代

绞杀者模式的优势就在于它是一种渐进的过程，容许新旧系统共存，并给予新系统成长的时间，它的另一个优点是能够降低风险。一旦新系统无法工作可以迅速的把流量切换回旧系统

**绞杀者应用**的开发过程有三个阶段

- **转换：**创建一个新应用
- **共存：**逐渐从旧系统中剥离功能并由新应用实现，使用反向代理或其他路由技术将现有的请求重定向到新应用中
- **删除：**当流量被转移到新应用后，逐步删除旧系统的功能模块，或者不在维护



## 云上重构

容器化仅仅是基础，**应用还需要通过编排实现生命周期管理**

### Kubernetes Pod

一般来说，将应用从容器转变为以Kubernetes Pod为载体的过程主要要做两件事

- 首先针对应用特性选择对应的**资源类型**
  - 比如最常用的无状态服务使用Deployment
  - 有状态服务选择StatefulSet
  - 守护进程选择DaemonSet
  - 任务相关的选择Job、CronJob。
- 然后将**服务暴露**出去使得集群内或者集群外能够访问

### 外部流量

进入应用的**外部流量**有两种

- 一种是页面访问
- 另一种是OpenAPI

为了控制外部流量使用API Gateway作为入口网关，除基本的路由外，还实现了鉴权和限流等功能

### 内部流量

进入应用的**内部流量**也有两种

- 一种来自集群外部，其他系统对应用的访问
  - 使用ExternalName与Route53 DNS域名绑定来实现
- 另一种就是**微服务之间的调用**
  - 直接通过服务名方式访问

### 服务网格

随着微服务的不断增多，服务之间的调用拓扑也越加复杂，流量控制、治理和监控等需求也越来越重要

在应用中引入了Istio Service Mesh管理服务间的流量

- 通过服务网格实现了按类型的流量切分，将来自页面和API的请求分发到不同的Endpoint去处理
- 超时、重试、熔断这些弹性能力也可以通过声明式配置实现，无须手动编写控制逻辑

### 运维

和监控平台的整合让微服务应用的可观察性获得极大提升

- 应用的业务日志和请求日志都会存储在ELK中
- 流量指标也统一收集到监控平台的Prometheus系统，并通过Grafana Dashboard展示
- 分布式追踪系统，可以方便地查看服务的调用链路并进行根因分析

