# 秋招面试题总结

## Java基础

#### 1、Hashmap是怎么实现的，底层原理？

HashMap的底层使用数组+链表/红黑树实现。

`transient Node<K,V>[] table;`这表示HashMap是Node数组构成，其中Node类的实现如下，可以看出这其实就是个链表，链表的每个结点是一个<K,V>映射。

```java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next;
}
```

HashMap的每个下标都存放了一条链表。

**常量/变量定义**

```java
/* 常量定义 */

// 初始容量为16
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;
// 最大容量
static final int MAXIMUM_CAPACITY = 1 << 30;
// 负载因子，当键值对个数达到DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR会触发resize扩容 
static final float DEFAULT_LOAD_FACTOR = 0.75f;
// 当链表长度大于8，且数组长度大于MIN_TREEIFY_CAPACITY，就会转为红黑树
static final int TREEIFY_THRESHOLD = 8;
// 当resize时候发现链表长度小于6时，从红黑树退化为链表
static final int UNTREEIFY_THRESHOLD = 6;
// 在要将链表转为红黑树之前，再进行一次判断，若数组容量小于该值，则用resize扩容，放弃转为红黑树
// 主要是为了在建立Map的初期，放置过多键值对进入同一个数组下标中，而导致不必要的链表->红黑树的转化，此时扩容即可，可有效减少冲突
static final int MIN_TREEIFY_CAPACITY = 64;

/* 变量定义 */

// 键值对的个数
transient int size;
// 键值对的个数大于该值时候，会触发扩容
int threshold;
// 非线程安全的集合类中几乎都有这个变量的影子，每次结构被修改都会更新该值，表示被修改的次数
transient int modCount;
```

关于modCount的作用见[这篇blog](https://blog.csdn.net/u012926924/article/details/50452411)

> 在一个迭代器初始的时候会赋予它调用这个迭代器的对象的modCount，如果在迭代器遍历的过程中，一旦发现这个对象的modCount和迭代器中存储的modCount不一样那就抛异常。
> **Fail-Fast机制**：java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map。

**注意初始容量和扩容后的容量都必须是2的次幂**，为什么呢?

**hash方法**

先看散列方法

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

HashMap的散列方法如上，其实就是将hash值的高16位和低16位异或，我们将马上看到hash在与n - 1相与的时候，高位的信息也被考虑了，能使碰撞的概率减小，散列得更均匀。

在JDK 8中，HashMap的putVal方法中有这么一句

```java
if ((p = tab[i = (n - 1) & hash]) == null)
    tab[i] = newNode(hash, key, value, null);
```

关键就是这句`(n - 1) & hash`，这行代码是把待插入的结点散列到数组中某个下标中，其中hash就是通过上面的方法的得到的，为待插入Node的key的hash值，n是table的容量即`table.length`，2的次幂用二进制表示的话，只有最高位为1，其余为都是0。减去1，刚好就反了过来。比如16的二进制表示为10000，减去1后的二进制表示为01111，除了最高位其余各位都是1，保证了在相与时，可以使得散列值分布得更均匀（因为如果某位为0比如1011，那么结点永远不会被散列到1111这个位置），且当n为2的次幂时候有`(n - 1) & hash == hash % n`, 举个例子，比如hash等于6时候，01111和00110相与就是00110，hash等于16时，相与就等于0了，多举几个例子便可以验证这一结论。最后来回答为什么HashMap的容量要始终保持2的次幂

- **使散列值分布均匀**
- **位运算的效率比取余的效率高**

注意table.length是数组的容量，而`transient int size`表示存入Map中的键值对数。

`int threshold`表示临界值，当键值对的个数大于临界值，就会扩容。threshold的更新是由下面的方法完成的。

```java
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}

```

该方法返回大于等于cap的最小的二次幂数值。比如cap为16，就返回16，cap为17就返回32。

**put方法**

put方法主要由putVal方法实现：

- 如果没有产生hash冲突，直接在数组`tab[i = (n - 1) & hash]`处新建一个结点；
- 否则，发生了hash冲突，此时key如果和头结点的key相同，找到要更新的结点，直接跳到最后去更新值
- 否则，如果数组下标中的类型是TreeNode，就插入到红黑树中
- 如果只是普通的链表，就在链表中查找，找到key相同的结点就跳出，到最后去更新值；到链表尾也没有找到就在尾部插入一个新结点。接着判断此时链表长度若大于8的话，还需要将链表转为红黑树（注意在要将链表转为红黑树之前，再进行一次判断，若数组容量小于64，则用resize扩容，放弃转为红黑树）

**get方法**

get方法由getNode方法实现：

- 如果在数组下标的链表头就找到key相同的，那么返回链表头的值
- 否则如果数组下标处的类型是TreeNode，就在红黑树中查找
- 否则就是在普通链表中查找了
- 都找不到就返回null

remove方法的流程大致和get方法类似。

**HashMap的扩容，resize()过程？**

``` java
newCap = oldCap << 1
```

resize方法中有这么一句，说明是扩容后数组大小是原数组的两倍。

```java
Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
        table = newTab;
        if (oldTab != null) {
            for (int j = 0; j < oldCap; ++j) {
                Node<K,V> e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    // 如果数组中只有一个元素，即只有一个头结点，重新哈希到新数组的某个下标
                    if (e.next == null)
                        newTab[e.hash & (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                    else { // preserve order
                        // 数组下标处的链表长度大于1，非红黑树的情况
                        Node<K,V> loHead = null, loTail = null;
                        Node<K,V> hiHead = null, hiTail = null;
                        Node<K,V> next;
                        do {
                            next = e.next;
                            // oldCap是2的次幂，最高位是1，其余为是0，哈希值和其相与，根据哈希值的最高位是1还是0，链表被拆分成两条，哈希值最高位是0分到loHead。
                            if ((e.hash & oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            // 哈希值最高位是1分到hiHead
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            // loHead挂到新数组[原下标]处；
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            // hiHead挂到新数组中[原下标+oldCap]处
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
```

举个例子，比如oldCap是16，二进制表示是10000，hash值的后五位和oldCap相与，因为oldCap的最高位（从右往左数的第5位）是1其余位是0，因此hash值的该位是0的所有元素被分到一条链表，挂到新数组中原下标处，hash值该位为1的被分到另外一条链表，挂到新数组中原下标+oldCap处。举个例子：桶0中的元素其hash值后五位是0XXXX的就被分到桶0种，其hash值后五位是1XXXX就被分到桶4中。

#### 2、Java中的错误和异常？

Java中的所有异常都是Throwable的子类对象，Error类和Exception类是Throwable类的两个直接子类。

Error：包括一些严重的、程序不能处理的系统错误类。这些错误一般不是程序造成的，比如StackOverflowError和OutOfMemoryError。

Exception：异常分为运行时异常和检查型异常。

- 检查型异常要求必须对异常进行处理，要么往上抛，要么try-catch捕获，不然不能通过编译。这类异常比较常见的是IOException。
- 运行时异常，可处理可不处理，在编译时可以通过，异常在运行时才暴露。比如数组下标越界，除0异常等。



## 数据结构与算法

#### 5、说说常用的散列方法？解决哈希冲突的方法有哪些？

- 最常用的除留余数法（取余），大小为M的数组，key的哈希值为k，那么k % M的值一定是落在0-M-1之间的。
- 直接定址法。用一个函数对key作映射得到哈希值。如线性函数：`hash(key) = a * key + b`
- 其他（略）

解决哈希冲突的方法：

- 开放定址法：采用M大小的数组存放N个键值对，其中M > N。开放定址中最简单的是线性探测法，当发生碰撞时，直接检查散列表中的下一个位置。如果到了数组末尾，折回到索引0处继续查找。
- 链地址法：采用链表数组实现，当发生哈希冲突时，将冲突键值以头插或者尾插的方式插入数组下标所在的链表，HashMap中正是使用了这种方法。
- 再哈希法：当发生哈希冲突时，换一个散列函数重新计算哈希值。
- 公共溢出区法：建立一个基本表和溢出表，所有冲突的键值都存放到溢出表中。在查找时，先在基本表中查，相等，查找成功，如不相等则去溢出表中进行顺序查找。

#### 6、堆排序的过程说一下？

堆排序使用了最大堆/最小堆，拿数组升序排序来说，需要建立一个最大堆，基于数组实现的二叉堆可以看作一棵完全二叉树，其满足堆中每个父结点它左右两个结点值都大，且堆顶的元素最大。

- 将堆顶元素和数组最后一个元素交换，最大元素被交换数组最后一个位置，同时从堆中删除原来处于堆顶的最大元素
- 被交换到堆顶的元素一般会打破堆结构的定义，因此需要进行堆的调整（下沉）。将堆顶的元素和其左右两个结点比较，将三者中的最大的交换到堆顶，然后继续跟踪此结点，循环上述过程，直到他比左右两个结点都大时停止调整，此时堆调整完毕，再次满足堆结构的定义
- 重复以上两个过程。直到堆中只剩一个元素，此时排序完成

每次调整堆的平均时间为O(lg N)，因此对大小为N的数组排序，时间复杂度最差和平均都 O(N lg N).

#### 7、堆排序和快排应用场景的？时间复杂度和空间复杂度各是多少？

快排序在平均情况下，比绝大多数排序算法都快些。很多编程语言的sort默认使用快排，像Java的Array.sort()就采用了双轴快速排序 。堆排序使用堆实现，空间复杂度只有O(1)。堆排序使用堆的结构，能以O(1)的时间获得最大/最小值，在处理TOP K问题时很方便，另外堆还可以实现优先队列。

时间复杂度：

- 快排，平均O(N lg N) ,最差O(N^2)，这种情况发生在数组本身就有序，这样每次切分元素都是数组中的最小值，切分得就极为不平衡。
- 堆排序，平均和最差都是O(N lgN)。因为每次调整堆结构都是O(lg N)，因此对大小为N的数组排序，时间复杂度最差和平均都 O(N lg N).

空间复杂度：

- 快排，一般基于递归实现，需要使用系统栈O(lg N)
- 堆排序，额外空间复杂度O(1）

放一张神图

![](http://picmeup.oss-cn-hangzhou.aliyuncs.com/coding/975503-20170214211234550-1109833343.png)

#### 8、双向链表，给你Node a，在其后插入Node c？

```java
c.next = a.next;
a.next = c;
c.prev = a;
// 如果a不是最后一个结点，就有下面一句
c.next.prev = c;
```

#### 9、写并查集？

```java
public class UnionFind {
    // id相同的分量是连通的
    private int[] id;
    //连通分量的个数
    private int count;

    public UnionFind(int n) {
        count = n;
        id = new int[n];
        for (int i = 0; i < n; i++) {
            id[i] = i;
        }
    }
	// 所属连通分量的id
    public int find(int p) {
        return id[p];
    }
	// 将和p同一个连通分量的结点全部归到和q一个分量中，即将p所在连通分量与q所在连通分量合并。
	// 反过来也可以
	// if (id[i] == qID) {
	// id[i] = pID;
	// }
    public void union(int p, int q) {
        int pId = find(p);
        int qId = find(q);
        if (pId == qId) return;
        for (int i = 0; i < id.length; i++) {
            if (id[i] == pId) {
                id[i] = qId;
            }
        }
        // 合并后，连通分量减少1
        count--;
    }

    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }
}
```

还可以有优化的写法，一个连通分量看成是一棵树。同一个连通分量其树的根结点相同。

```java
public class UnionFind {
    private int[] parentTo;
    private int count;

    public UnionFind(int n) {
        count = n;
        parentTo = new int[n];
        for (int i = 0; i < n; i++) {
            parentTo[i] = i;
        }
    }

    public int find(int p) {
        // 向上一直到根结点
        // p = parentTo[p]说明到达树的根结点，返回根结点
        while (p != parentTo[p]) {
            p = parentTo[p];
        }
        return p;
    }
	// 这行的意思就是q所在连通分量和q所在连通分量合并
	// 从树的角度来看，p树的根结点成为了q树根结点的孩子结点
	// 反过来也可以，parentTo[qRoot] = pRoot;
    public void union(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);
        if (pRoot == qRoot) return;
        parentTo[pRoot] = qRoot;
        count--;
    }

    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }
}
```

## 并发/多线程

#### 7、BIO、NIO、AIO的区别？

首先要搞明白在I/O中的同步、异步、阻塞、非阻塞是什么意思。

- 同步I/O。由用户进程自己处理I/O的读写，处理过程中不能做其他事。需要主动去询问I/O状态。

- 异步I/O。由系统内核完成I/O操作，完成后系统会通知用户进程。

- 阻塞。I/O请求操作需要的条件不满足，请求操作一直等待，直到条件满足。

- 非阻塞。 I/O请求操作需要的条件不满足，会立即返回一个标志，而不会一直等待。

现在来看BIO、NIO、AIO的区别。

**BIO**：同步并阻塞。用户进程在发起一个I/O请求后，必须等待I/O准备就绪，I/O操作也由自己来处理，在IO操作未完成之前，用户进程必须等待。 

**NIO**：同步非阻塞。用户进程发起一个I/O请求后可立即返回去做其他任务，当I/O准备就绪时它会收到通知。接着由这个线程自行进行I/O操作，I/O操作本身还是同步的。

**AIO**：异步非阻塞。用户进程发起一个I/O操作以后可立即返回去做其他任务，真正的I/O操作由内核完成后通知用户进程。

NIO和AIO的不同：NIO是操作系统通知用户进程I/O已经准备就绪，由用户进程自行完成I/O操作；AIO是操作系统完成I/O后通知用户进程。 

BIO是为每一个客户端连接开启一个线程，简单说就是一个连接一个线程。

NIO主要组件有Seletor、Channel、Buffer，数据需要通过BUffer包装后才能使用Channel进行读取和写入。一个Selector可以由一个线程管理，每一个Channel可看作一个客户端连接。一个Selector可以监听多个Channel，即使用一个或极少数的线程来管理大量的客户端连接。当与客户端连接的数据没有准备好时，Selector处于等待状态，一旦某个Channel的准备好了数据，Selector就能立即得到通知。

#### 8、两个线程交替打印奇数和偶数？

先使用synchronized实现。PrintOdd用于打印奇数；PrintEven用于打印偶数。核心就是判断当前count如果是奇数，就让PrintEven阻塞，PrintOdd打印后唤醒在lock对象上等待的PrintEven并且释放锁。此时PrintEven获得锁打印偶数再唤醒PrintOdd，两个线程如此交替唤醒对方就实现了交替打印奇偶数。

```java
public class PrintOddEven {
    private static final Object lock = new Object();
    private static int count = 1;

    static class PrintOdd implements Runnable {
        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                synchronized (lock) {
                    try {
                        while ((count & 1) != 1) {
                            lock.wait();
                        }
                        System.out.println(Thread.currentThread().getName() + " " +count);
                        count++;
                        lock.notify();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    static class PrintEven implements Runnable {
        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                synchronized (lock) {
                    try {
                        while ((count & 1) != 0) {
                            lock.wait();
                        }
                        System.out.println(Thread.currentThread().getName() + " " +count);
                        count++;
                        lock.notify();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    public static void main(String[] args) {
        new Thread(new PrintOdd()).start();
        new Thread(new PrintEven()).start();
    }
}
```

如果要实现3个线程交替打印ABC呢？这次打算使用重入锁，和上面没差多少，但是由于现在有三个线程了，在打印完后需要唤醒其他线程，注意不可使用`sigal()`，因为唤醒的线程是随机的，不能保证打印顺序不说，还会造成死循环。一定要使用`sigalAll()`唤醒所有线程。

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class ThreeThreadPrintABC {
    private static ReentrantLock lock = new ReentrantLock();
    private static Condition wait = lock.newCondition();
    // 用来控制该打印的线程
    private static int count = 0;

    public static void main(String[] args) {
        Thread printA = new Thread(new PrintA());
        Thread printB = new Thread(new PrintB());
        Thread printC = new Thread(new PrintC());
        printA.start();
        printB.start();
        printC.start();

    }

    static class PrintA implements Runnable {
        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                lock.lock();
                try {
                    while ((count % 3) != 0) {
                        wait.await();
                    }
                    System.out.println(Thread.currentThread().getName() + " A");
                    count++;
                    wait.signalAll();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    lock.unlock();
                }
            }
        }
    }

    static class PrintB implements Runnable {
        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                lock.lock();
                try {
                    while ((count % 3) != 1) {
                        wait.await();
                    }
                    System.out.println(Thread.currentThread().getName() + " B");
                    count++;
                    wait.signalAll();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    lock.unlock();
                }
            }
        }
    }

    static class PrintC implements Runnable {
        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                lock.lock();
                try {
                    while ((count % 3) != 2) {
                        wait.await();
                    }
                    System.out.println(Thread.currentThread().getName() + " C");
                    count++;
                    wait.signalAll();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    lock.unlock();
                }
            }
        }
    }
}

```

如果觉得不好理解，重入锁是可以绑定多个条件的。创建3个Condition分别让三个打印线程在上面等待。A打印完了，唤醒等待在waitB对象上的PrintB；B打印完了唤醒在waitC对象上的PrintC；C打印完了，唤醒在waitA对象上等待的PrintA，如此循环地唤醒对方即可。

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class ThreeThreadPrintABC {
    private static ReentrantLock lock = new ReentrantLock();
    private static Condition waitA = lock.newCondition();
    private static Condition waitB = lock.newCondition();
    private static Condition waitC = lock.newCondition();
    // 用来控制该打印的线程
    private static int count = 0;

    public static void main(String[] args) {
        Thread printA = new Thread(new PrintA());
        Thread printB = new Thread(new PrintB());
        Thread printC = new Thread(new PrintC());
        printA.start();
        printB.start();
        printC.start();

    }

    static class PrintA implements Runnable {
        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                lock.lock();
                try {
                    while ((count % 3) != 0) {
                        waitA.await();
                    }
                    System.out.println(Thread.currentThread().getName() + " A");
                    count++;
                    waitB.signal();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    lock.unlock();
                }
            }
        }
    }

    static class PrintB implements Runnable {
        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                lock.lock();
                try {
                    while ((count % 3) != 1) {
                        waitB.await();
                    }
                    System.out.println(Thread.currentThread().getName() + " B");
                    count++;
                    waitC.signal();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    lock.unlock();
                }
            }
        }
    }

    static class PrintC implements Runnable {
        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                lock.lock();
                try {
                    while ((count % 3) != 2) {
                        waitC.await();
                    }
                    System.out.println(Thread.currentThread().getName() + " C");
                    count++;
                    waitA.signal();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    lock.unlock();
                }
            }
        }
    }
}


```

#### 10、原子类比如AtomicInteger为什么能保证原子性？

JDK并发包下有一个atomic包，里面实现了一些直接使用CAS操作的线程安全的类型。AtomicInteger就是其中之一。得益于CAS操作，因此保证了原子性。CAS操作具体说一说是什么？

CAS(Compare And Swap)，即“比较并交换”。CAS基于乐观的态度，是无锁操作，它操作包含三个参数，当前要更新的变量、期望值、新值，仅当：当前值和预期值一样时，才会将当前值设置为新值；如果当前值和预期值不一样，说明这个变量已经被其他线程修改过了。如果有多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新。其他线程允许放弃操作，也允许再次尝试，直到修改成功为止。CAS操作是由硬件支持的，现在的处理器基本支持原子化的CAS指令。

CAS由什么缺点？如何解决？

可能引发"ABA"问题，即一个变量原来是A，先被修改成B后又修改回了A，由于CAS操作只是比较当前值和预期值是否一样（只比较结果，不在乎过程中状态的变化），在其他线程来看，该变量就好像没有发生过变化。

可以为数据添加时间戳，每次成功修改数据时，不仅更新数据的值，同时要更新时间戳的值。CAS操作时，不仅要比较当前值和预期值，还要比较当前时间戳和预期时间戳。两者都必须满足预期值才能修改成功。



#### 12、实现生产者-消费者模型？

可以有几种方式实现生产者-消费者模型：

- wait()/notify()

- await()/signal()

- BlockingQueue

生产者-消费者问题的关键在于：

- 没有“产品”时，消费者不能消费
- “产品”线满时，生产者不能生产

如果用队列来存放“产品”：

- 队列为空时，消费者需要一直等待，不为空时消费者才能取走。
- 队列为满时，生产者需要一直等待，不为满时生产者才能进行生产。

等待和唤醒可以使用wait()/notify()实现。Java中的阻塞队列BlockingQueue，其`take()`和和`put()`方法就是阻塞的，内部其实就是await()/signal()方法的配合使用，非常适合作为数据传输的通道。

以ArrayBlockingQueue来说，同步是重入锁保证的。和该lock绑定了两个Condition，一个是notEmpty一个是notFull。简单说明下take和put方法。注意这并不是源码，只是方便理解把核心部分抽取出来。

```java
public E take() {
    lock.lock();
    try {
        // 当队列为空，不能取，必须等待
        while (count==0) {
            notEmpty.await();
        }
        // 不再阻塞说明队列有元素了，直接删除并返回
        return dequeue();
    } finally ｛
        lock.unlock();
	}
}

private void enqueue(E x) {
    // ...insert element
    // 因为插入了元素，说明队列不为空，唤醒在notEmpty上等待的线程
    notEmpty.signal();
}

public void put(E e) {
    lock.lock();
    try {
        // 队列满了，不能放入，必须等待
        while (count == items.length) {
            notFull.await();
        }
        // 此时队列不为满，可以放入
        enqueue(e);
    } finally {
        lock.unlock();
    }
}

private E dequeue() {
    // ...delete element
    // 移除了元素，因而队列不为满，唤醒在notFull上等待的线程
    E x = (E) items[takeIndex];
    notFull.signal();
    return x;
}
```

了解了原理，现在用阻塞队列实现生产者-消费者模型

```java
package easy;

import java.util.Random;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;

public class ProducerConsumer {
    public static class Producer implements Runnable {
        private BlockingQueue<Integer> blockingQueue;
        private Random random = new Random();

        public Producer(BlockingQueue<Integer> blockingQueue) {
            this.blockingQueue = blockingQueue;
        }

        @Override
        public void run() {
            while (true) {
                Integer a = makeProduct();
                try {
                    blockingQueue.put(a);
                    System.out.println(Thread.currentThread().getName() + "生产了" + a + " 队列大小" + blockingQueue.size());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }

        public Integer makeProduct() {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return random.nextInt(10);
        }
    }

    public static class Consumer implements Runnable {
        private BlockingQueue<Integer> blockingQueue;

        public Consumer(BlockingQueue<Integer> blockingQueue) {
            this.blockingQueue = blockingQueue;
        }


        @Override
        public void run() {
            while (true) {
                Integer a = useProduct();
                System.out.println(Thread.currentThread().getName() + "消费产品" + a + " 队列大小" + blockingQueue.size());
            }
        }

        public Integer useProduct() {
            Integer a = null;
            try {
                a = blockingQueue.take();
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return a;
        }
    }

    public static void main(String[] args) {
        BlockingQueue<Integer> blockingQueue = new LinkedBlockingQueue<>(5);
        ExecutorService exec = Executors.newCachedThreadPool();
        int producerNum = 3;
        int consumerNum = 5;

        for (int i = 0; i < producerNum; i++) {
            exec.submit(new Producer(blockingQueue));
        }
        for (int i = 0; i < consumerNum; i++) {
            exec.submit(new Consumer(blockingQueue));
        }

    }
}
```

#### 13、介绍下J.U.C.下的类？

- java.util.concurrent.locks包下的ReentrantLock，即重入锁。可以实现同步，是synchronized的扩展。还有ReadWriteLock即读写锁，读-读非阻塞，读和读之间可并行，因此适合读多写少的场合。
- ConcurrentHashMap，线程安全的HashMap；
- CopyOnWriteArrayList，核心是在写入操作时，先用一个副本复制原数组，然后新值写入到副本中，写入完成后再将修改完的副本替换掉原来的数组。这种实现使得写入操作也不会阻塞读操作了，只有写-写会同步等待。适合读多写少的场合。
- 阻塞队列BlockingQueue，有基于数组实现的有界队列ArrayBlockingQueue，还有基于链表实现的无界队列LinkedBlockingQueue。
- ConcurrentLinkedQueue，高效地并发队列。
- 信号量Semaphore，允许多个线程同时访问，synchronized和重入锁都只允许在一个时刻只有一个线程可以进入临界区访问共享资源，而信号量允许多个线程同时访问某一个资源。
- 倒计时器CountDownLatch，给倒计时器设定一个计数个数，每完成一个任务计数减1，某一个线程等待在倒计时器上，当计数完毕后才能继续该线程的执行。强调一个线程等待其他线程执行完成后才能继续执行。
- 循环栅栏CyclicBarrier，和CountDownLatch比较类似，可传入一个Runnable，该计数器可循环使用，每次计数完成会执行该Runnable。更强调线程之间的互相等待，必须所有线程等准备完毕（一次计数完成），才能执行某个任务。
- 跳表ConcurrentSkipListMap，跳表是一个多层的链表结构，最下层拥有全部的键值数据，越往上越少；查找时从顶层开始查找，在本层没找到转到下一层接着查找，用于快速查找，而且跳表中的数据是已排序的。
- 线程池，Executor、Executors、EexcutorService、ThreadPoolExecutor等。Executors是一个线程池工厂，其静态方法通过返回new ThreadPool，以EexcutorService接收，而EexcutorService和ThreadPoolExecutor都是Executor的实现类。
- Fork/Join框架，如ForkJoinPool线程池
- atomic包下的各种原子类，如AtomicInteger，主要使用了CAS操作实现无锁
- LockSupport类，线程阻塞工具类，主要有park和unpark方法表示线程的挂起和唤醒，

#### 14、读写锁用过没？

ReadWriteLock即读写锁，它有两个方法如下，分别返回一个读锁和写锁，即读写锁分离。

```java
ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
Lock readLock = readWriteLock.readLock();
Lock writeLock = readWriteLock.writeLock();
```

在读时使用readLock进行加锁，在写时使用writeLock进行加锁。使得读-读不阻塞，读线程完全并行，适合读多写少的场合。

#### 15、自旋锁是什么，为什么要用自旋锁？自选锁的缺点？

指当一个线程在获取锁的时候，锁已经被其它线程获取，但是有可能锁的状态只会持续很短的一段时间，为此将线程挂起、恢复并不值得，因为线程的挂起和恢复都需要转入到内核态。系统假定未请求到锁的线程在不久之后就能获得这锁，于是让后面请求锁的那个线程执行一个忙循环，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环 。这就是自旋锁。

自旋锁的好处：不会使线程状态发生改变，即一直处于用户态，不会转入内核态（用户态和内核态的切换系统开销很大）。不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快。

自旋锁的缺点：一直占用CPU时间，如果锁被占用时间很短，自旋等待效果就很好，如果锁占用时间太长，自旋的线程只会白白消耗CPU资源。

后来引入了自适应自旋锁，自旋时间不再是固定的了，由上一次在同一个锁上的自旋时间和锁的拥有者的状态决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，且持有锁的线程正在运行中，虚拟机认为这次自旋也会成功，而且它将允许自旋等待持续更长的时间；相反，如果对于某个锁，自旋很少成功获得过，在以后要获取这个锁时可能就会省略自旋过程。

#### 20、ConcurrentHashMap是如何保证线程安全的？

JDK 7中使用的是分段锁，内部分成了16个Segment即分段，每个分段可以看作是一个小型的HashMap，每次put只会锁定一个分段，降低了锁的粒度：

- 首先根据key计算出一个hash值，找到对应的Segment
- 调用Segment的lock方法（Segment继承了重入锁），锁住该段内的数据，所以并没有锁住ConcurrentHashMap的全部数据
- 根据key计算出hash值，找到Segment中数组中对应下标的链表，并将该数据放置到该链表中
- 判断当前Segment包含元素的数量大于阈值，则Segment进行扩容（Segment的个数是不能扩容的，但是单个Segment里面的数组是可以扩容的）

多线程put的时候，只要被加入的键值不属于 同一个分段，就可以做到真正的并行put。**对不同的Segment则无需考虑线程同步，对于同一个Segment的操作才需考虑。**

JDK 8中使用了CAS+synchronized保证线程安全，也采取了数组+链表/红黑树的结构。 

put时使用synchronized锁住了桶中链表的头结点。

数组的扩容，被问到了我在看吧.....我只知道多个线程可以协助数据的迁移。

有这么一个问题，ConcurrentHashMap，有三个线程，A先put触发了扩容，扩容时间很长，此时B也put会怎么样？此时C调用get方法会怎么样？C读取到的元素是旧桶中的元素还是新桶中的

A先触发扩容，ConcurrentHashMap迁移是在锁定旧桶的前提下进行迁移的，并没有去锁定新桶。

- 在某个桶的迁移过程中，别的线程想要对该桶进行put操作怎么办？一旦某个桶在迁移过程中了，必然要获取该桶的锁，所以其他线程的put操作要被阻塞。**因此B被阻塞**。
- 某个桶已经迁移完成（其他桶还未完成），别的线程想要对该桶进行put操作怎么办？该线程会首先检查是否还有未分配的迁移任务，如果有则先去执行迁移任务，如果没有即全部任务已经分发出去了，那么此时该线程可以直接对新的桶进行插入操作（映射到的新桶必然已经完成了迁移，所以可以放心执行操作）

ConcurrentHashMap的get操作没有加锁，所以可以读取到值，不过是旧桶中的值。

```java
if (finishing) {
    nextTable = null;
    table = nextTab;
    sizeCtl = (n << 1) - (n >>> 1);
    return;
}
```

从table = nextTable可以看出，当所有数据迁移完成时，才将用nextTab新数组去覆盖旧数组table。所以在A扩容过程中，**C读取到的是旧数组中的元素**。

#### 21、ThreadLocal的作用和实现原理？

对于共享变量，一般采取同步的方式保证线程安全。而ThreadLocal是为每一个线程都提供了一个线程内的局部变量，每个线程只能访问到属于它的副本。

实现原理，下面是set和get的实现

 ```java
// set方法
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}

// 上面的getMap方法
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}

// get方法
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}
 ```

从源码中可以看出：每一个线程拥有一个ThreadLocalMap，这个map存储了该线程拥有的所有局部变量。

set时先通过Thread.currentThread()获取当前线程，进而获取到当前线程的ThreadLocalMap，然后以ThreadLocal自己为key，要存储的对象为值，存到当前线程的ThreadLocalMap中。

get时也是先获得当前线程的ThreadLocalMap，以ThreadLocal自己为key，取出和该线程的局部变量。

题话外，一个线程内可以设置多个ThreadLocal，这样该线程就拥有了多个局部变量。比如当前线程为t1，在t1内创建了两个ThreadLocal分别是tl1和tl2，那么t1的ThreadLocalMap就有两个键值对。

```java
t1.threadLocals.set(tl1, obj1) // 等价于在t1线程中调用tl1.set(obj1)
t1.threadLocals.set(tl2, obj2) // 等价于在t1线程中调用tl2.set(obj1)

t1.threadLocals.getEntry(tl1) // 等价于在t1线程中调用tl1.get()获得obj1
t1.threadLocals.getEntry(tl2) // 等价于在t1线程中调用tl2.get()获得obj2
```

#### 22、ArrayBlockingQueue和LinkedBlockingQueue的区别？

- ArrayBlockingQueue基于数组，是有界的阻塞队列，初始化时需要指定容量且不可扩容；LinkedBlockingQueue基于链表，是无界的阻塞队列，容量无限制。
- ArrayBlockingQueue读写共用一把锁，因此put和take是互相阻塞的；而LinkedBlockingQueue使用了两把锁，一把putLock和一把takeLock，实现了锁分离，使得put和take写数据和读数据可以并发的进行。

#### 23、CountDownLatch和CyclicBarrier的区别？

- CountDownLatch强调一个线程等待其他所有线程，通过cdl.await()让当前线程等待在倒计数器上，每有一个线程执行完，cdl.countDown()，将计数减1，减到0时通知当前线程执行。简单的说就是一个线程等待，直到他所等待的其他线程都执行完成，当前线程才可以继续执行。
- cyclicBarrier强调线程之间互相等待，只要有一个线程还没到来，所有线程会一起等待。可以传入一个Runnable作为计数完成要执行的任务。每有一个线程调用cyc.await()计数减1，减到0时会执行一次该Runnable。简单地说就是线程之间互相等待，等所有线程都准备好，即调用await()方法之后，执行一次Runnable，此时所有线程开始同时执行！
- CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。

#### 24、synchronized内部实现原理？

推荐阅读下面两篇博客。

[倔强中的小白](https://blog.csdn.net/tryingpfq/article/details/82115612)

[zejian_的博客](https://blog.csdn.net/javazejian/article/details/72828483)

对同步方法，JVM采用`ACC_SYNCHRONIZED`标记符来实现同步。 对于同步代码块。JVM采用`monitorenter`、`monitorexit`两个指令来实现同步。

同步方法通过`ACC_SYNCHRONIZED`关键字隐式的对方法进行加锁。当线程要执行的方法被标注上`ACC_SYNCHRONIZED`时，需要先获得锁才能执行该方法。

同步代码块通过`monitorenter`和`monitorexit`执行来进行加锁。当线程执行到`monitorenter`的时候要先获得所锁，才能执行后面的方法。当线程执行到`monitorexit`的时候则要释放锁。

每个对象自身维护这一个被加锁次数的计数器，当计数器数字为0时表示可以被任意线程获得锁。当计数器不为0时，只有获得锁的线程才能再次获得锁，即可重入锁。换句话说，一个线程获取到锁之后可以无限次地进入该临界区。

Synchronized原子性

原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。

在Java中，为了保证原子性，提供了两个高级的字节码指令`monitorenter`和`monitorexit`。而这两个字节码指令，在Java中对应的关键字就是`synchronized`。通过`monitorenter`和`monitorexit`指令，可以保证被`synchronized`修饰的代码在同一时间只能被一个线程访问，在锁未释放之前，无法被其他线程访问到。因此，在Java中可以使用`synchronized`来保证方法和代码块内的操作是原子性的。

Synchronized可见性

可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。`synchronized`修饰的代码，在开始执行时会加锁，执行完成后会进行解锁。而为了保证可见性，有一条规则是这样的：对一个变量解锁之前，必须先把此变量同步回主存中。这样解锁后，后续线程就可以访问到被修改后的值。

Synchronized有序性

有序性即程序执行的顺序按照代码的先后顺序执行。由于`synchronized`修饰的代码，同一时间只能被同一线程访问。那么也就是单线程执行的。所以，可以保证其有序性。

#### 

#### 6、讲一讲垃圾回收算法？

- 复制算法，一般用于新生代的垃圾回收
- 标记清除， 一般用于老年代的垃圾回收
- 标记整理，一般用于老年代的垃圾回收
- 分代收集：根据对象存活周期的不同把Java堆分为新生代和老年代。新生代中又分为Eden区、from survivor区和to survivor区，默认8:1:1，对象默认创建在Eden区，每次垃圾收集时新生代都会有大量对象死亡。此时利用复制算法将Eden区和from survivor区还存活的对象一并复制到to survivor区。老年代的对象存活率高，没有额外空间进行分配担保，因此采用标记-清除或者标记-整理的算法进行回收。前者会产生空间碎片，而后者不会。

#### 7、介绍下类加载器和类加载过程？

**先说类加载器**。

在Java中，系统提供了三种类加载器。

- 启动类加载器（Bootstrap ClassLoader），启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要委派给启动类加载器，直接使用null。
- 扩展类加载器（Extension ClassLoader）
- 应用程序类加载器（Application ClassLoader），负责加载用户类路径（ClassPath）上锁指定的类库。是程序中默认的类加载器。

当然用户也可以自定义类加载器。

**再说类加载的过程**。

主要是以下几个过程：

```html
加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载
```

**加载**

- 通过一个类的全限定名获取定义该类的二进制字节流
- 将字节流表示的静态存储结构转化为方法区的运行时数据结构
- 在内存中生成这个类的Class对象，作为方法区这个类的各种数据的访问入口

**验证**

- 文件格式验证：比如检查是否以魔数0xCAFEBABE开头
- 元数据验证：对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。比如检查该类是否继承了被final修饰的类。
- 字节码验证，通过数据流和控制流的分析，验证程序语义是合法的、符合逻辑的。

**准备**。
为类变量（static）分配内存并设置默认值。比如static int a = 123在准备阶段的默认值是0，但是如果有final修饰，在准备阶段就会被赋值为123了。

**解析**。

将常量池中的符号引用替换成直接引用的过程。包括类或接口、字段、类方法、接口方法的解析。

**初始化**。

按照程序员的计划初始化类变量。如static int a = 123，在准备阶段a的值被设置为默认的0，而到了初始化阶段其值被设置为123。

#### 8、什么是双亲委派模型，有什么好处？如何打破双亲委派模型？

类加载器之间满足双亲委派模型，即：除了顶层的启动类加载器外，其他所有类加载器都必须要自己的父类加载器。当一个类加载器收到类加载请求时，自己首先不会去加载这个类，而是不断把这个请求委派给父类加载器完成，因此所有的加载请求最终都传递给了顶层的启动类加载器。只有当父类无法完成这个加载请求时，子类加载器才会尝试自己去加载。

双亲委派模型的好处？使得Java的类随着它的类加载器一起具备了一种带有优先级的层次关系。Java的Object类是所有类的父类，因此无论哪个类加载器都会加载这个类，因为双亲委派模型，所有的加载请求都委派给了顶层的启动类加载器进行加载。所以Object类在任何类加载器环境中都是同一个类。

如何打破双亲委派模型？使用OSGi可以打破。*OSGI*(Open Services Gateway Initiative)，或者通俗点说JAVA动态模块系统。可以实现代码热替换、模块热部署。在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构。

#### 9、说一说CMS和G1垃圾收集器？各有什么特点。

CMS(Concurrent Mark Sweep) 从名字可以看出是可以进行并发标记-清除的垃圾收集器。针对老年代的垃圾收集器，目的是尽可能地减少用户线程的停顿时间。

收集过程有如下几个步骤：

- 初始标记：标记从GC Roots能直接关联到的对象，会暂停用户线程
- 并发标记：即在堆中堆对象进行可达性分析，从GC Roots开始找出存活的对象，可以和用户线程一起进行
- 重新标记：修正并发标记期间因用户程序继续运作导致标记产生变动的对象的标记记录
- 并发清除：并发清除标记阶段中确定为不可达的对象

CMS的缺点：

- 由于是基于标记-清除算法，所以会产生空间碎片
- 无法处理浮动垃圾，即在清理期间由于用户线程还在运行，还会持续产生垃圾，而这部分垃圾还没有被标记，在本次无法进行回收。
- 对CPU资源敏感

CMS比较类似适合用户交互的场景，可以获得较小的响应时间。

G1(Garbage First)，有如下特点：

- 并行与并发
- 分代收集
- 空间整合 ：整体上看是“标记-整理”算法，局部（两个Region之间 ）看是复制算法。确保其不会产生空间碎片。（这是和CMS的区别之一）
- 可预测的停顿：G1除了追求低停顿外，还能建立可预测的时间模型，主要原因是它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。

在使用G1收集器时，Java堆的内存划分为多个大小相等的独立区域，新生代和老年代不再是物理隔离。G1跟踪各个区域的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的区域。

G1的收集过程和CMS有些类似：

- 初始标记：标记与GC Roots直接关联的对象，会暂停用户线程（Stop the World）
- 并发标记：并发从GC Roots开始找出存活的对象，可以和用户线程一起进行
- 最终标记：修正并发标记期间因用户程序继续运作导致标记产生变动的对象的标记记录
- 筛选回收：清除标记阶段中确定为不可达的对象，具体来说对各个区域的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。

G1的优势：可预测的停顿；实时性较强，大幅减少了长时间的gc；一定程度的高吞吐量。

#### 10、CMS和G1的区别？

由上一个问题可总结出CMS和G1的区别：

- G1堆的内存布局和其他垃圾收集器不同，它将整个Java堆划分成多个大小相等的独立区域(Region)。G1依然保留了分代收集，但是新生代和老年代不再是物理隔离的，它们都属于一部分Region的集合，因此仅使用G1就可以管理整个堆。
- CMS基于标记-清除，会产生空间碎片；G1从整体看是标记-整理，从局部（两个Region之间）看是复制算法，不会产生空间碎片。
- G1能实现可预测的停顿。

#### 11、GC一定会导致停顿吗，为什么一定要停顿？任意时候都可以GC吗还是在特定的时候？

GC进行时必须暂停所有Java执行线程，这被称为Stop The World。为什么要停顿呢？因为可达性分析过程中不允许对象的引用关系还在变化，否则可达性分析的准确性就无法得到保证。所以需要STW以保证可达性分析的正确性。

程序执行时并非在所有地方都能停顿下来开始GC，只有在“安全点”才能暂停。安全点指的是：HotSpot没有为每一条指令都生成OopMap（Ordinary Object Pointer），而是在一些特定的位置记录了这些信息。这些位置就叫安全点。

## 数据库

#### 1、数据库设计的三大范式？

- 第一范式1NF: 数据表中的每一列(字段)，必须是不可拆分的最小单元，也就是确保每一列的原子性。如订单信息列为orderInfo = "DD1024 2018.5.18"，必须拆分为orderId和orderTime。
- 第二范式2NF: 在满足第一范式的基础上，表中的所有列都必需依赖于主键（和主键有关系），其他和主键没有关系的列可以拆分出去。通俗点说就是：一个表只描述一件事情。比如order表中有orderId、orderTime、userId和userName，只有前两列依赖于订单表，后两列需要拆分到user表中。
- 第三范式3NF: 在满足第二范式的基础上，要求数据不能有传递关系。表中的每一列都要与主键直接相关，而不是间接相关（表中的每一列只能依赖于主键）。比如order表中有orderId、orderTime、userId和userName，根据orderId可以查出userId，根据userId又可以查出userName，这就是数据的传递性，完全可以只留下userId这一列。

#### 2、MySql的事务隔离级别？推荐使用哪种？

- 读未提交
- 读已提交
- 可重复读
- 串行化

在具体解释上面的四个隔离级别前。有必要了解事务的**四大特性（ACID）**

[推荐阅读这篇博客](https://www.cnblogs.com/huanongying/p/7021555.html)

- 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
- 一致性（Consistency）：事务开始前和结束后，数据的完整性约束没有被破环。比如A向B转了钱，转账前后钱的总数不变。
- 隔离性（Isolation）：多个用户并发访问数据数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间的数据相互隔离。比如事务A和事务B都修改同一条记录，这条记录就会被重复修改或者后者会覆盖前者的修改记录。
- 持久性（Durability）：事务完成后，事务对数据库的更新被保存到数据库，其结果是永久的。

事务并发可能产生的问题：
脏数据：事务对缓冲池中的行记录进行修改，但是还没有被提交。

- 脏读：事务A读取到了事务B修改但未提交的数据。如果此时B回滚到修改之前的状态，A就读到了脏数据。
- 不可重复读：事务A多次读取同一个数据，此时事务B在A读取过程中对数据修改并提交了，导致事务A在同一个事务中多次读取同一数据而结果不同。
- 幻读：事务A对表进行修改，这个修改涉及到表中所有的行，但此时事务B新插入了一条数据，事务A就会发现居然还有数据没有被修改，就好像发生幻觉一样。

脏读是读取到事务未提交的数据，不可重复度读读取到的是提交提交后的数据，只不过在一次事务中读取结果不一样。

不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。

![821187-20160811171241606-133220585](http://picmeup.oss-cn-hangzhou.aliyuncs.com/coding/821187-20160811171241606-133220585.jpg)

一般来说，数据库隔离级别不一样，可能出现的并发问题也不同。级别最高的是串行化，所有问题都不会出现。但是在并发下性能极低，可重复读会只会导致幻读。

所以一般使用MySQL默认的可重复读即可。MVCC（多版本并发控制）使用undo_log使得事务可以读取到数据的快照（某个历史版本），从而实现了可重复读。MySQL采用Next-Key Lock算法，对于索引的扫描不仅是锁住扫描到的索引，还锁住了这些索引覆盖的范围，避免了不可重复读和幻读的产生。

#### 3、MySql数据库在什么情况下出现死锁？产生死锁的四个必要条件？如何解决死锁？

死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象，若无外力作用两个事务都无法推进，这样就产生了死锁。下去 死锁的四个必要条件：

- 互斥条件：即任何时刻，一个资源只能被一个进程使用。其他进程必须等待。
- 请求和保持条件：即当资源请求者在请求其他的资源的同时保持对原有资源的占有且不释放。 
- 不剥夺条件：资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。 
- 环路等待条件：比如A占有B在等待的资源（B等待A释放），B占有A在等待的资源（A等待B释放）。多个进程循环等待着相邻进程占用着的资源。

避免死锁可以通过破环四个必要条件之一。

解决死锁的方法：

- 加锁顺序保持一致。不同的加锁顺序很可能导致死锁，比如哲学家问题：A先申请筷子1在申请筷子2，而B先申请筷子2在申请筷子1，最后谁也得不到一双筷子（同时拥有筷子1和筷子2）
- 超时，为其中一个事务设置等待时间，若超过这个阈值事务就回滚，另一个等待的事务就能得以继续执行。
- 及时检测出死锁，回滚undo量最小的事务。一般是采用等待图（wait-for gragh）。采用深度优先搜索的算法实现，如果图中有环路就说明存在死锁。

#### 4、现在发现sql查询很慢，如何分析哪里出了问题，应该如何优化？

开启慢查询，查找哪些sql语句执行得慢。使用explain查看语句的执行计划，比如有没有使用到索引，是否启用了全表扫描等。查询慢，很大可能是因为没有使用索引或者索引没有被命中。还有其他的原因，比如发生了死锁，硬件、网速等原因。

优化手段：为相关列添加索引，并且确保索引可以被命中。优化sql语句的编写。

#### 5、索引的好处？

索引是对数据库表中一个或多个列的值进行排序的结构。MySql中索引是B+树，在查找时可以利用二分查找等高效率的查找方式，以O(lg n)的时间找到。因此索引可以加快查询速度。

#### 6、哪些情况需要建立索引？

- 在经常要搜索的列上
- 经常出现在where后面的列上
- 在作为主键的列上
- 作为外键的列上
- 经常需要排序、分组和联合操作的字段建立索引

哪些情况不适合建立索引？

- 查询中很少使用的字段
- 数值太少的字段
- 唯一性不太差的字段
- 更新频繁的字段
- 不会出现在where后的字段
- 索引适合建立在小字段上，text和blob等大字段不适合建立索引

#### 7、索引的最左匹配原则了解吗？

建了一个(a,b,c)的联合索引，那么实际等于建了(a),(a,b),(a,b,c)三个索引，但是有时在条件查询时只会匹配到a或者(a, b)而不会匹配到(a, b, c)。下面的例子

```sql
SELECT * FROM table WHERE a = 1 AND c = 3; // 使用了索引a，c不走索引
SELECT * FROM table WHERE a = 1 AND b < 2 AND c = 3; // 使用到了索引(a,b)，c不走索引
```

建立联合索引(a, b ,c)，所以索引是按照a -> b -> c的顺序进行排序的。a-b-c这样的索引是先找a，然后在范围里面找b，再在范围内找c。 所以上面的语句里的c 会分散在很多个b里面且不是排序的，所以没办法走索引。

举个例子比如(a, b)联合索引，先按a排序再按b排序，得到

```sql
(1,1)->(1, 2)->(2, 1)  (2, 4)->(3, 1)->(3, 2)
```

如果执行`select a from table where b=2`，就没有使用到(a, b)这个联合索引，因为b的值1,2,1,4,1,2显然不是排序的。

具体来说：MySQL会从左开始一直向右匹配直到遇到范围查询（>,<,BETWEEN,LIKE）就停止匹配，比如： a = 1 AND b = 2 AND c > 3 AND d = 4，如果建立 （a,b,c,d）顺序的索引，使用了索引(a, b, c)，但是d是没有走索引的，如果建立（a,b,d,c）的索引，则可以命中索引(a, b, c, d)，其中a,b,d的顺序可以任意调整。

等于（=）和in 可以乱序。比如，a = 1 AND b = 2 AND c = 3 建立（a,b,c）索引可以任意顺序。

#### 8、如何建立复合索引，可以使sql语句能尽可能匹配到索引？

- 等于条件的索引放在前面（最左），范围查询放在后面。` a = 1 AND b = 2 AND c > 3 AND d = 4`，建立（a, b, d, c）就是不错的选择；
- 先过滤后排序（ORDER BY）如`SELECT * FROM t WHERE c = 100 and d = 'xyz' ORDER BY b`建立(c, d, b)联合索引就是不错的选择
- 对于索引列的查询，一般不建议使用LIKE操作，像`LIKE '%abc'`这样的不能命中索引；不过`LIKE 'abc%'`可以命中索引。

#### 9、建立了索引，索引就一定会被命中吗？或者说索引什么时候失效

- 使用了`not in, <>,!=`则不会命中索引。注：`<>`是不等号
- innoDB引擎下，若使用OR，只有前后两个列都有索引才能命中（执行查询计划，type是index_merge），否则不会使用索引。
- 模糊查询中，通配符在最前面时，即`LIKE '%abc'`这样不能命中索引
- 对列进行函数运算的情况（如 where md5(password) = "xxxx"）
- 联合索引中，遇到范围查询时，其后的索引不会被命中
- 存了数字的char或varchar类型，常见的如用字符串表示的手机号，在查询时不加引号，则不会命中（如where phone=‘13340456789’能命中，where phone=13340456789不能命中）
- 当数据量小时，MySQL发现全表扫描反而比使用索引查询更快时不会使用索引。

#### 10、为什么要使用联合索引？

> MySQL5.0之前，一个表一次只能使用一个索引，无法同时使用多个索引分别进行条件扫描。但是从5.1开始，引入了 index merge 优化技术，对同一个表可以使用多个索引分别进行条件扫描。

[推荐阅读这篇博客](https://www.jianshu.com/p/XgXfhf)

- **减少开销**。建了一个(a,b,c)的联合索引，相当于建了(a),(a,b),(a,b,c)三个索引 
- **覆盖索引**。减少了随机IO操作。同样的有复合索引（a,b,c），如果有如下的sql: select a,b,c from table where a=1 and b = 1。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作
- **效率高**。索引列越多，通过索引筛选出的数据越少。比如有1000W条数据的表，有如下sql:select * from table where a = 1 and b =2 and c = 3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W*10%=100w 条数据，然后再回表从100w条数据中找到符合b=2 and c= 3的数据，然后再排序，再分页；如果是复合索引，通过索引筛选出1000w *10% *10% *10%=1w，然后再排序、分页。

#### 11、既然索引可以加快查询速度，索引越多越好是吗？

[推荐阅读这篇优博客](https://www.jb51.net/article/81875.htm)

大多数情况下索引能大幅度提高查询效率，但数据的变更（增删改）都需要维护索引，因此更多的索引意味着更多的维护成本和更多的空间 （一本100页的书，却有50页目录？）而且过小的表，建立索引可能会更慢（读个2页的宣传手册，你还先去找目录？）

#### 12、主键和唯一索引的区别？

- 主键是一种约束，唯一索引是索引，一种数据结构。
- 主键一定是唯一索引，唯一索引不一定是主键。
- 一个表中可以有多个唯一索引，但只能有一个主键。
- 主键不允许空值，唯一索引允许。
- 主键可以做为[外键](https://www.baidu.com/s?wd=%E5%A4%96%E9%94%AE&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)，唯一索引不行； 

#### 13、B+树和B-树的区别？

B-树是一种平衡的多路查找树。2-3树和2-3-4树都是B-树的特例。一棵M阶的B-树，除了根结点外的其他非叶子结点，最多含有M-1对键和链接，最少含有M/2对键和链接。根结点可以少于M/2，但是也不能少于2对。

- 关键字集合分布在整颗树中
- 每个元素在该树中只出现一次，可能在叶子结点上，也可能在非叶子结点上。
- 搜索有可能在非叶子结点结束。
- 所有叶子结点位于同一层

B+树是B-树的变体，也是一种多路查找树。

- 非叶子结点值可以看作索引，仅含有其子树中的最大（或）最小关键字。
- 叶子结点保存了所有关键字，且叶子结点按照从小到大的顺序排列，是一个双向链表结构。
- 只能在叶子节点命中搜索

B+ 树更适合用于数据库和操作系统的文件系统中。 

假设一个结点就是一个页面，B树遍历所有记录，通过中序遍历的方式，要多次返回到父结点，同一个结点多次访问了，增加了磁盘I/O操作的次数。B+因为在叶子结点存放了所有的记录，而且是双向链表的结构，只需在叶子节点这一层就能遍历所有记录，大大减少了磁盘I/O操作，所以数据库索引用B+树结构更好。

#### 14、聚集索引与非聚集索引的区别？

- 对于聚集索引，表记录的排列顺序和与索引的排列顺序是一致的；非聚集索引不是
- 聚集索引就是按每张表的主键构造一棵B+树，每张表只能拥有一个聚集索引；一张表可以有多个非聚集索引
- 聚集索引的叶子结点存放的是整张表的行记录数据；非聚集索引的叶子结点并不包含行记录的全部数据，除了包含键值还包含一个书签——即相应行数据的聚集索引键。因此通过非聚集索引查找时，先根据叶子结点的指针获得指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录。

#### 15、InnoDB和MyISAM引擎的区别？

- InnoDB支持事务，MyISAM不支持
- InnoDB是行锁设计，MyISAM是表锁设计
- InnoDB支持外键，MyISAM不支持
- InnoDB采用聚集的方式，每张表按照主键的顺序进行存放。如果没有主键，InnoDB会为每一行生成一个6字节的ROWID并以此为主键；MyISAM可以不指定主键和索引
- InnoDB没有保存表的总行数，因此查询行数时会遍历整表；而MyISAM有一个变量存储可表的总行数，查询时可以直接取出该值
- InnoDB适合联机事务处理(OLTP)，MyISAM适合联机分析处理(OLAP)

#### 16、`COUNT(*)`和`COUNT(1)`的区别？`COUNT(列名)`和`COUNT(*)`的区别？

`COUNT(*)`和`COUNT(1)`没区别。`COUNT(列名)`和`COUNT(*)`区别在于前者不会统计列为NULL的数据，后者会统计。 

#### 17、数据库中悲观锁和乐观锁讲一讲？

悲观锁：总是假设在并发下会出现问题，即假设多个事务对同一个数据的访问会产生冲突。当其他事务想要访问数据时，会在临界区提前加锁，需要将其阻塞挂起。比如MySQL中的排他锁（X锁）、和共享锁（S锁）

乐观锁： 总是假设任务在并发下是安全的，即假设多个事务对同一个数据的访问不会发生冲突，因此不会加锁，就对数据进行修改。当遇到冲突时，采用CAS或者版本号、时间戳的方式来解决冲突。数据库中使用的乐观锁是版本号或时间戳。乐观并发控制（OCC）是一种用来解决写-写冲突的无锁并发控制，不用加锁就尝试对数据进行修改，在修改之前先检查一下版本号，真正提交事务时，再检查版本号有，如果不相同说明已经被其他事务修改了，可以选择回滚当前事务或者重试；如果版本号相同，则可以修改。

 提一下乐观锁和MVCC的区别，其实MVCC也利用了版本号，和乐观锁还是能扯上些关系。

MVCC主要解决了读-写的阻塞，因为读只能读到数据的历史版本（快照）；OCC主要解决了写-写的阻塞，多个事务对数据进行修改而不加锁，更新失败的事务可以选择回滚或者重试。

>  当多个用户/进程/线程同时对数据库进行操作时，会出现3种冲突情形：读-读，不存在任何问题；读-写，有隔离性问题，可能遇到脏读、不可重复读 、幻读等。写-写，可能丢失更新。多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，读操作只读该事务开始前的数据库的快照，实现了一致性非锁定读。 这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读。乐观并发控制（OCC）是一种用来解决写-写冲突的无锁并发控制，不用加锁就尝试对数据进行修改，在修改之前先检查一下版本号，真正提交事务时，再检查版本号有，如果不相同说明已经被其他事务修改了，可以选择回滚当前事务或者重试；如果版本号相同，则可以修改。 

#### 18、MySQL的可重复读是如何实现的？

MVCC（多版本并发控制）使用undo_log使得事务可以读取到数据的快照（某个历史版本），从而实现了可重复读。MySQL采用Next-Key Lock算法，对于索引的扫描不仅是锁住扫描到的索引，还锁住了这些索引覆盖的范围，避免了不可重复读和幻读的产生。

具体来说：

在可重复读下： select....from会采用MVCC实现的一致性非锁定读，读取的是事务开始的快照，避免了不可重复读。select .....from .... for update会采用 Next-Key Locking来保证可重复读和幻读。

在读已提交下: select....from 会采用快照，读取的是最新一份的快照数据，不能够保证不可重复读和幻读；select .....from .... for update会采用Record Lock，不能够保证不可重复读/幻读。 

#### 19、覆盖索引是什么？

如果一个索引包含(或覆盖)所有需要查询的字段的值，即只需扫描索引而无须回表，这称为“覆盖索引”。InnoDB的辅助索引在叶子节点中保存了部分键值信息以及指向聚集索引键的指针，如果辅助索引叶子结点中的键值信息已经覆盖了要查询的字段，就没有必要利用指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录了。

#### 20、MySQL中JOIN和UNION什么区别？

UNION 操作符用于合并两个或多个 SELECT 语句的结果集。UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相同的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。默认情况下，UNION会过滤掉重复的值。使用 UNION ALL则会包含重复的值。

JOIN用于连接两个有关联的表，筛选两个表中满足条件（ON后的条件）的行记录得到一个结果集。从结果集中SELECT的字段可以是表A或者表B中的任意列。

JOIN常用的有LEFT JOIN、RIGHT JOIN、INNER JOIN。

- LEFT JOIN会以左表为基础，包含左表的所有记录，以及右表中匹配ON条件的记录，对于未匹配的列，会以NULL表示。
- LEFT JOIN会以右表为基础，包含左表的所有记录，以及右表匹配ON条件的记录，对于未匹配的列，会以NULL表示。
- INNER JOIN，产生两个表的交集（只包含满足ON条件的记录）

![231634008872011](http://picmeup.oss-cn-hangzhou.aliyuncs.com/coding/231634008872011.png)

INNER JOIN

![231634016379381](http://picmeup.oss-cn-hangzhou.aliyuncs.com/coding/231634016379381.png)

FULL OUTER JOIN

![231634027315181](http://picmeup.oss-cn-hangzhou.aliyuncs.com/coding/231634027315181.png)

![231634045743650](http://picmeup.oss-cn-hangzhou.aliyuncs.com/coding/231634045743650.png)

LEFT JOIN

![231634072774691](http://picmeup.oss-cn-hangzhou.aliyuncs.com/coding/231634072774691.png)

RIGHT JOIN和LEFT JOIN类似。

![241947220904425](http://picmeup.oss-cn-hangzhou.aliyuncs.com/coding/241947220904425.jpg)

#### 21、WHERE和HAVING的区别？

- WHERE过滤的是行，HAVING过滤分组。
- WHERE能完成的，都可以用HAVING(只是有时候没必要)
- WHERE在分组前对数据进行过滤，HAVING在分组后对数据进行过滤
- WHERE后不能接聚合函数，HAVING后面通常都有聚合函数

#### 22、SQL注入是什么，如何防止？

所谓SQL注入式攻击，就是攻击者把SQL命令插入到Web表单的输入域或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令。

比如在登录界面，如果用户名填入`'xxx' OR 1=1 --`就能构造下面的SQL语句，因为OR 1=1，password被注释掉，因此无论name和password填入什么都能登录成功。

```sql
SELECT * FROM USER WHERE NAME='xxx' OR 1=1 -- and password='xxx';
```

使用PrepareStatement，可以防止sql注入攻击，sql的执行需要编译，注入问题之所以出现，是因为用户填写 sql语句参与了编译。使用PrepareStatement对象在执行sql语句时，会分为两步，第一步将sql语句 "运送" 到mysql上预编译，再回到java端拿到参数运送到mysql端。**预先编译好，也就是SQL引擎会预先进行语法分析，产生语法树，生成执行计划，也就是说，后面你输入的参数，无论你输入的是什么，都不会影响该sql语句的语法结构了。用户填写的 sql语句，就不会参与编译，只会当做参数来看。从而避免了sql注入问题。**

## SSM

#### 1、Spring有什么好处（特性），怎么管理对象的？

- IOC：Spring的IOC容器，将对象之间的创建和依赖关系交给Spring，降低组件之间的耦合性。即Spring来控制对象的整个生命周期。其实就是平常说的DI或者IOC。
- AOP：面向切面编程。可以将应用各处的功能分离出来形成可重用的组件。核心业务逻辑与安全、事务、日志等这些非核心业务逻辑分离，使得业务逻辑更简洁清晰。

- 使用模板消除了样板式的代码。比如使用JDBC访问数据库。
- 提供了对像关系映射（ORM）、事务管理、远程调用和Web应用的支持。

Spring使用IOC容器创建和管理对象，比如在XML中配置了类的全限定名，然后Spring使用反射+工厂来创建Bean。BeanFactory是最简单的容器，只提供了基本的DI支持，ApplicationContext基于BeanFactory创建，提供了完整的框架级的服务，因此一般使用应用上下文。

#### 2、什么是IOC？

IOC(Inverse of Control)即控制反转。可以理解为控制权的转移。传统的实现中，对象的创建和依赖关系都是在程序进行控制的。而现在由Spring容器来统一管理、对象的创建和依赖关系，控制权转移到了Spring容器，这就是控制反转。

#### 3、什么是DI？DI的好处是什么？

DI(Dependency Injection)依赖注入。对象的依赖关系由负责协调各个对象的第三方组件在创建对象的时候进行设定，对象无需自行创建或管理它们的依赖关系。通俗点说就是Spring容器为对象注入外部资源，设置属性值。DI的好处是使得各个组件之间松耦合，一个对象如果只用接口来表明依赖关系，这种依赖可以在对象毫不知情的情况下，用不同的具体类进行替换。

**IOC和DI其实是对同一种的不同表述**。

#### 4、什么是AOP，AOP的好处？

AOP(Aspect-Oriented Programming)面向切面编程，可以将遍布在应用程序各个地方的功能分离出来，形成可重用的功能组件。系统的各个功能会重复出现在多个组件中，各个组件存在于核心业务中会使得代码变得混乱。使用AOP可以将这些多处出现的功能分离出来，不仅可以在任何需要的地方实现重用，还可以使得核心业务变得简单，实现了将核心业务与日志、安全、事务等功能的分离。

具体来说，散布于应用中多处的功能被称为*横切关注点*，这些横切关注点从概念上与应用的业务逻辑是相分离的，但是又常常会直接嵌入到应用的业务逻辑中，AOP把这些横切关注点从业务逻辑中分离出来。安全、事务、日志这些功能都可以被认为是应用中的横切关注点。

通常要重用功能，可以使用继承或者委托的方式。但是继承往往导致一个脆弱的对像体系；委托带来了复杂的调用。面向切面编程仍然可以在一个地方定义通用的功能，但是可以用声明的方法定义这个功能要在何处出现，而无需修改受到影响的类。**横切关注点可以被模块化为特殊的类，这些类被称为切面（Aspect）**。好处在于：

- 每个关注点都集中在一个地方，而非分散在多处代码中；
- 使得业务逻辑更简洁清晰，因为这样可以只关注核心业务，次要的业务被分离成关注点转移到切面中了。

AOP术语介绍

**通知**：切面所做的工作称为通知。通知定义了切面是什么，以及在何时使用。Spring切面可以应用5种类型的通知

- 前置通知（Before）：在目标方法被调用之前调用通知功能；
- 后置通知（After）：在目标方法被调用或者抛出异常之后都会调用通知功能；
- 返回通知（After-returning）：在目标方法成功执行之后调用通知；
- 异常通知（After-throwing）：在目标方法抛出异常之后调用通知；
- 环绕通知（Around）：通知包裹了被通知的方法，在目标方法被调用之前和调用之后执行自定义的行为。
  

**连接点**：可以被通知的方法

**切点**：实际被通知的方法

**切面**：即通知和切点的结合，它是什么，在何时何处完成其功能。

**引入**：允许向现有的类添加新方法或属性，从而可以在无需修改这些现有的类情况下，让它们具有新的行为和状态。

**织入**：把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入：

- 编译期，切面在目标类编译时织入。
- 类加载期，切面在目标类加载到JVM时被织入。
- 运行期，切面在应用运行的某个时刻被织入，**在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的**。

Spring AOP构建在动态代理基础之上，所以Spring对AOP的支持仅限于方法拦截。

Spring的切面是由包裹了目标对象的代理类实现的。代理类封装了目标类，并拦截被通知方法的调用，当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。**其实切面只是实现了它们所包装bean相同接口的代理**。

#### 5、AOP的实现原理：Spring AOP使用的动态代理。

Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理。JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。

如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。

Spring使用动态代理，代理类封装了目标类，当代理拦截到方法调用时，在调用目标bean的方法之前，会执行切面逻辑。

#### 6、Spring的生命周期？

Spring创建、管理对象。Spring容器负责创建对象，装配它们，配置它们并管理它们的整个生命周期。

- 实例化：Spring对bean进行实例化
- 填充属性：Spring将值和bean的引用注入到bean对应的属性中
- 调用BeanNameAware的setBeanName()方法：若bean实现了BeanNameAware接口，Spring将bean的id传递给setBeanName方法
- 调用BeanFactoryAware的setBeanFactory()方法：若bean实现了BeanFactoryAware接口，Spring调用setBeanFactory方法将BeanFactory容器实例传入
- 调用ApplicationContextAware的setApplicationContext方法：如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext方法将bean所在的应用上下文传入
- 调用BeanPostProcessor的预初始化方法：如果bean实现了BeanPostProcessor，Spring将调用它们的叛postProcessBeforeInitialization方法
- 调用InitalizingBean的afterPropertiesSet方法：如果bean实现了InitializingBean接口，Spring将调用它们的afterPropertiesSet方法
- 如果bean实现了BeanPostProcessor接口，Spring将调用它们的postProcessAfterInitialzation方法
- 此时bean已经准备就绪，可以被应用程序使用，它们将一直驻留在应用杀死那个下文中，直到该应用的上下文被销毁。
- 如果bean实现了DisposableBean接口，Spring将调用它的destroy方法。

####  7、Spring的配置方式，如何装配bean？bean的注入方法有哪些？

- XML配置，如`<bean id="">`
- Java配置即JavaConfig，使用`@Bean`注解
- 自动装配，组件扫描（component scanning）和自动装配（autowiring），`@ComponentScan`和`@AutoWired`注解

bean的注入方式有：

- 构造器注入
- 属性的setter方法注入
  

推荐对于强依赖使用构造器注入，对于弱依赖使用属性注入。

#### 8、bean的作用域？

- 单例（Singleton）：在整个应用中，只创建bean一个实例。
- 原型（Prototype）：每次注入或通过Spring应用上下文获取时，都会创建一个新的bean实例。
- 会话（Session）：在Web应用中，为每个会话创建一个bean实例。
- 请求（Request）：在Web应用中，为每个请求创建一个bean实例。

默认情况下Spring中的bean都是单例的。

#### 9、Spring中涉及到哪些设计模式？

- 工厂方法模式。在各种BeanFactory以及ApplicationContext创建中都用到了；
- 单例模式。在创建bean时用到，Spring默认创建的bean是单例的；
- 代理模式。在AOP中使用Java的动态代理；
- 策略模式。比如有关资源访问的Resource类
- 模板方法。比如使用JDBC访问数据库，JdbcTemplate。
- 观察者模式。Spring中的各种Listener，如ApplicationListener
- 装饰者模式。在Spring中的各种Wrapper和Decorator
- 适配器模式。Spring中的各种Adapter，如在AOP中的通知适配器AdvisorAdapter

#### 10、MyBatis和Hibernate的区别和应用场景？

Hibernate :是一个标准的ORM(对象关系映射) 框架； SQL语句是自己生成的，程序员不用自己写SQL语句。因此要对SQL语句进行优化和修改比较困难。适用于中小型项目。

MyBatis： 程序员自己编写SQL， SQL修改和优化比较自由。 MyBatis更容易掌握，上手更容易。主要应用于需求变化较多的项目，如互联网项目等。

## 海量数据处理

首先要了解几种数据结构和算法：

- HashMap，记住对于同一个键，哈希出来的值一定是一样的，不同的键哈希出来也可能一样，这就是发生了冲突（或碰撞）。
- BitMap，可以看成是bit数组，数组的每个位置只有0或1两种状态。Java中可以使用int数组表示位图，arr[0]是一个int，一个int是32位，故可以表示0-31的数，同理arr[1]可表示32-63...实际上就是用一个32位整型表示了32个数。
- 大/小根堆，O(1)时间可在堆顶得到最大值/最小值。利用小根堆可用于求Top K问题。
- 布隆过滤器。使用长度为m的bit数组和k个Hash函数，某个键经过k个哈希函数得到k个下标，将k个下标在bit数组中对应的位置设置为1。对于每个键都重复上述过程，得到最终设置好的布隆过滤器。对于新来的键，使用同样的过程，得到k个下标，判断k个下标在bit数组中的值是否为1，若有一个不为1，说明这个键一定不在集合中。若全为1，也可能不在集合中。就是说：查询某个键，判断不属于该集合是绝对正确的；判断属于该集合是低概率错误的。因为多个位置的1可能是由不同的键散列得到。

对上亿个无重复数字的排序，或者找到没有出现过数字，注意因为无重复数字，而BitMap的0和1正好可以表示该数字有没有出现过。如果要求更小的内存，可以先分出区间，对落入区间的进行计数。必然有的区间数量未满，再遍历一次数组，只看该区间上的数字，使用BitMap，遍历完成后该区间中必然有没被设置成0的的地方，这些地方就是没出现的数。

数据在小范围内波动，比如人类年龄，而且数据允许重复，可用计数排序处理数值排序或查找没有出现过的值，计数的桶中频次为0的就是没有出现过的数。

数据是数字，要找最大的Top K，直接用大小为K的小根堆，不断淘汰最小元素即可。

数据是数字或非数字，要找频次最高的Top K。可使用HashMap统计频次，统计出频次最大的前K个即可。统计频次选出前K的过程可以用小根堆。还可以用Hash分流的方法，即用一个合适的hash函数将数据分到不同的机器或者文件中，因为对于同样的数据，由于hash函数的性质，必然被分配到同一个文件中，因此不存在相同的数据分布在不同的文件这种情况。对每个文件采用HashMap统计频次，用小根堆选出Top K，然后汇总全部文件，从所有部分结果的Top K中再利用小根堆得到最终的Top K。

查找数值的排名，比如找到中位数。比如将数划分区间，对落入每个区间的数进行计数。然后可以得知中位数落在哪个区间，再遍历所有数，这次只关心落在该区间的数，不划分区间的对其进行计数，就可以找出中位数。

## 操作系统

#### 2、写一个LRU？

Least Recently Used(LRU)，即最近最少使用页面置换算法。**选择最长时间没有被引用的页面进行置换**，思想是：如果一个页面很久没有被引用到，那么可以认为在将来该页面也很少被访问到。

当发生缺页（CPU要访问的页不在内存中），计算内存中每个页上一次被访问的时间，置换上次使用到当前时间最长的一个页面。

如何实现？可以使用双向链表+哈希表的方式

维护一个按最近一次访问时间排序的页面链表。

- 链表头结点是最近刚刚访问过的页面
- 链表尾结点是最久未被访问的页面

HashMap主要是为了判断是否命中缓存。

访问内存时，若命中缓存，找到响应的页面，将其移动到链表头部，表示该页面是最近刚刚访问的。缺页时，将链表尾部的页面移除，同时新页面放到链表头。

```java
import java.util.HashMap;
import java.util.LinkedList;

public class LRUCache2<K,V> {
    private final int cacheSize;
    private LinkedList<K> cacheList = new LinkedList<>();
    private HashMap<K,V> map = new HashMap<>();

    public LRUCache2(int cacheSize) {
        this.cacheSize = cacheSize;
    }

    public synchronized void put(K key, V val) {
        if (!map.containsKey(key)) {
            if (map.size() >= cacheSize) {
                removeLastElement();
            }
            cacheList.addFirst(key);
            map.put(key, val);
        } else {
            moveToFirst(key);
        }
    }

    public V get(K key) {
        if (!map.containsKey(key)) {
            return null;
        }
        moveToFirst(key);
        return map.get(key);
    }

    private synchronized void moveToFirst(K key) {
        cacheList.remove(key);
        cacheList.addFirst(key);
    }

    private synchronized void removeLastElement() {
        K key = cacheList.removeLast();
        map.remove(key);
    }

    @Override
    public String toString() {
        return cacheList.toString();
    }

    public static void main(String[] args) {
        LRUCache2<String,String> lru = new LRUCache2<>(4);
        lru.put("C", null);
        lru.put("A", null);
        lru.put("D", null);
        lru.put("B", null);
        lru.put("E", null);
        lru.put("B", null);
        lru.put("A", null);
        lru.put("B", null);
        lru.put("C", null);
        lru.put("D", null);

        System.out.println(lru);
    }
}

/* out:
[D, C, B, A] 
*/
```

Java的LinkedHashMap是双向链表和HashMap的结合。可以直接用其搞定，构造方法设置参数`accessOrder=true`即可按访问顺序排序。而`removeEldestEntry`就是用来删除最久未被使用的结点。

```java
import java.util.LinkedHashMap;
import java.util.Map;

public class LRUCache<K,V> extends LinkedHashMap<K, V> {
    static final float LOAD_FACTOR = 0.75f;
    static final boolean ACCESS_ORDER = true;
    private int cacheSize;
    public LRUCache(int initialCapacity, int cacheSize) {
        super(initialCapacity, LOAD_FACTOR, ACCESS_ORDER);
        this.cacheSize = cacheSize;
    }

    @Override
    protected synchronized boolean removeEldestEntry(Map.Entry eldest) {
        return size() > cacheSize;
    }

    @Override
    public V get(Object key) {
        return super.get(key);
    }

    @Override
    public synchronized V put(K key, V value) {
        return super.put(key, value);
    }

    public static void main(String[] args) {
        LRUCache<String, String> lru = new LRUCache<>(4, 4);
        lru.put("C", null);
        lru.put("A", null);
        lru.put("D", null);
        lru.put("B", null);
        lru.put("E", null);
        lru.put("B", null);
        lru.put("A", null);
        lru.put("B", null);
        lru.put("C", null);
        lru.put("D", null);

        System.out.println(lru);
    }
}

```

上面打印是{A, B, C, D}这样的顺序，倒过来就行了（我也不知道为啥要这样）。

## 其他

#### 1、你说你用到了线性回归，怎么理解回归的意思？

线性回归的英文是Regression toward the mean，直译就是"回归到均值"。各种数据都有其平均值，比如人类的身高。高的人大概率孩子也高，矮的人大概率孩子也矮，但是高的人身高每增加一个单位，其孩子可能只能增加半个单位；矮的人身高每减少一个单位，其孩子可能只会减少半个单位。也就是子代的平均高度会向着一个中心趋势靠拢，这就是回归到均值。

回归问题等价于函数拟合，线性回归也就是用线性的函数去拟合所有观测数据，利用最小二乘法使得误差（预测值和真实值差值的平方和）最小化。对于新的观测数据，使用该函数计算得到一个预测值。

#### 2、一个c/c++程序是怎么从代码到可执行文件的？

额，面试官是C++的吧，然而我面Java。

[推荐这篇博客](https://blog.csdn.net/f905699146/article/details/72877413)

主要经历以下步骤：

- 预处理
- 编译
- 汇编
- 链接

![20170606130136651](http://picmeup.oss-cn-hangzhou.aliyuncs.com/coding/20170606130136651.jpg)

编译的过程又分为以下几步：词法分析，语法分析，语义分析，源代码优化，代码生成和目标代码优化

![20170606133523278](http://picmeup.oss-cn-hangzhou.aliyuncs.com/coding/20170606133523278.png)

然后链接的过程如下

![20170606134035683](http://picmeup.oss-cn-hangzhou.aliyuncs.com/coding/20170606134035683.jpg)

#### 3、一致性哈希了解吗？

[推荐阅读这篇博客](http://www.zsythink.net/archives/1182)

这是一种分布式数据缓存的方案，常用于负载均衡。解决将许多缓存均匀分布到各个服务器上的问题。

- 首先求出服务器（节点）的哈希值，一致性哈希算法将哈希值对`2^32`取模，将服务器配置到0～2^32的圆上。

- 然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。

- 然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过2^32仍然找不到服务器，就会保存到第一台服务器上。

![Snipaste_2018-09-02_23-22-06](http://picmeup.oss-cn-hangzhou.aliyuncs.com/coding/Snipaste_2018-09-02_23-22-06.png)

优点：

- 在删除服务器结点后，失效的缓存只是一部分，不会影响到所有缓存
- 新增服务器结点，缓存迁移的代价很小

但是有时会出现服务器hash得不均匀的情况，这样有大量的缓存都存在一个服务器中。

![Snipaste_2018-09-02_23-27-46](http://picmeup.oss-cn-hangzhou.aliyuncs.com/coding/Snipaste_2018-09-02_23-27-46.png)

这种情况可以通过设置虚拟节点，如图中淡蓝色中的A、B、C就是虚拟结点。添加虚拟结点后，1、3被分到A中，4、5分到B中，2、6被分到C中，分布就很均匀了。

![Snipaste_2018-09-02_23-29-43](http://picmeup.oss-cn-hangzhou.aliyuncs.com/coding/Snipaste_2018-09-02_23-29-43.png)

#### 5、写一个观察者模式？

![0df5d84c-e7ca-4e3a-a688-bb8e68894467](http://picmeup.oss-cn-hangzhou.aliyuncs.com/coding/0df5d84c-e7ca-4e3a-a688-bb8e68894467.png)

先定义主题和观察者的接口。

```java
public interface Subject {
    void resisterObserver(Observer o);

    void removeObserver(Observer o);

    void notifyObserver();
}

public interface Observer {
    void update(float temp, float humidity, float pressure);
}
```

然后是实现类，这里以Head First里经典的气象站为例。

```java
public class WeatherData implements Subject {
    private List<Observer> observers;
    private float temperature;
    private float humidity;
    private float pressure;

    public WeatherData() {
        observers = new ArrayList<>();
    }

    public void setMeasurements(float temperature, float humidity, float pressure) {
        this.temperature = temperature;
        this.humidity = humidity;
        this.pressure = pressure;
        notifyObserver();
    }

    @Override
    public void resisterObserver(Observer o) {
        observers.add(o);
    }

    @Override
    public void removeObserver(Observer o) {
        int i = observers.indexOf(o);
        if (i >= 0) {
            observers.remove(i);
        }
    }

    @Override
    public void notifyObserver() {
        for (Observer o : observers) {
            o.update(temperature, humidity, pressure);
        }
    }
}
```

```java
/* 观察者1 */
public class StatisticsDisplay implements Observer {

    public StatisticsDisplay(Subject weatherData) {
        weatherData.resisterObserver(this);
    }

    @Override
    public void update(float temp, float humidity, float pressure) {
        System.out.println("StatisticsDisplay.update: " + temp + " " + humidity + " " + pressure);
    }
}
```

```java
/* 观察者2 */
public class CurrentConditionsDisplay implements Observer {

    public CurrentConditionsDisplay(Subject weatherData) {
        weatherData.resisterObserver(this);
    }

    @Override
    public void update(float temp, float humidity, float pressure) {
        System.out.println("CurrentConditionsDisplay.update: " + temp + " " + humidity + " " + pressure);
    }
}
```

```java
/* 测试类 */
public class WeatherStation {
    public static void main(String[] args) {
        WeatherData weatherData = new WeatherData();
        CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData);
        StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);

        weatherData.setMeasurements(0, 0, 0);
        weatherData.setMeasurements(1, 1, 1);
    }
}
```

 
